[{"categories":["travel"],"content":"Tokyo! Even though the trip was very rushed, it seemed to be enough for me. Even if I had extra time, I'd probably just roam around, see a few more landmarks and buildings, and enjoy more of the renowned local delicacies. Perhaps for every traveler, every city has its own advantages to admire.","date":"2023-09-19","objectID":"/en/posts/travel/tokyo/","tags":["Tokyo","Japan"],"title":"2023.9.14～2023.9.17 Tokyo, Japan","uri":"/en/posts/travel/tokyo/"},{"categories":["travel"],"content":"Mood This is my first trip abroad after the pandemic, and also my first since starting work. I’ve suddenly experienced the joy of taking leave. Our company’s policy of converting annual leave into cash does seem to have garnered a lot of labor with no additional days off throughout the year. Having gone a year and a half without wanting/daring to take leave, this trip made me realize that with well-planned holidays, the annual leave is sufficient for two trips abroad. The money earned from cashing in annual leave might be enough for a week’s getaway, but the fatigue from working without a break all year cannot be erased. Even if the money is at hand, there’s no time to spend it. Always feeling this way seems very distant from the “carpe diem” attitude I aspired to in college. Perhaps I’ll increasingly become “afraid” to spend. Over the past few days, I find myself envying those groups of people lounging in the park. I fantasize about being able to lie on the grass with good friends on every comfortable day, chatting away, and breaking into hearty laughter when someone brings up something funny. There are quite a few photos. I really love live photos; the brief sound and movement, compared to static images, help me recall the emotions and feelings when I lifted the camera. I’m no longer inclined to post all the pictures on my blog. Instead, I’ll keep them in an album to occasionally trigger my memories of Tokyo. ","date":"2023-09-19","objectID":"/en/posts/travel/tokyo/:1:0","tags":["Tokyo","Japan"],"title":"2023.9.14～2023.9.17 Tokyo, Japan","uri":"/en/posts/travel/tokyo/"},{"categories":["travel"],"content":"The park Such a good weather ","date":"2023-09-19","objectID":"/en/posts/travel/tokyo/:2:0","tags":["Tokyo","Japan"],"title":"2023.9.14～2023.9.17 Tokyo, Japan","uri":"/en/posts/travel/tokyo/"},{"categories":["leetcode hard"],"content":"my solution","date":"2023-09-10","objectID":"/en/posts/lc/hard/1359_count_all_valid_pickup_and_delivery_options/","tags":["dp"],"title":"1359. Count All Valid Pickup and Delivery Options","uri":"/en/posts/lc/hard/1359_count_all_valid_pickup_and_delivery_options/"},{"categories":["leetcode hard"],"content":"https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/ https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/submissions/1045563113/ class Solution { public: int countOrders(int n) { vector\u003cint\u003e dp(n + 1); dp[1] = 1; for(int i = 2; i \u003c= n; ++i){ int tn = (2 * i - 1); int sn = (tn * (tn + 1)) / 2; dp[i] = (long long)dp[i - 1] * sn % 1000000007; } return dp[n]; } }; Looked Hint ","date":"2023-09-10","objectID":"/en/posts/lc/hard/1359_count_all_valid_pickup_and_delivery_options/:0:0","tags":["dp"],"title":"1359. Count All Valid Pickup and Delivery Options","uri":"/en/posts/lc/hard/1359_count_all_valid_pickup_and_delivery_options/"},{"categories":["leetcode medium"],"content":"my solution","date":"2023-09-02","objectID":"/en/posts/lc/medium/2707_extra_characters_in_a_string/","tags":["dp","hash"],"title":"2707. Extra Characters in a String","uri":"/en/posts/lc/medium/2707_extra_characters_in_a_string/"},{"categories":["leetcode medium"],"content":"https://leetcode.com/problems/extra-characters-in-a-string/ https://leetcode.com/problems/extra-characters-in-a-string/submissions/1038162877/ class Solution { public: vector\u003cint\u003e ans; unordered_map\u003cstring, bool\u003e mp; int minExtraChar(string s, vector\u003cstring\u003e\u0026 dictionary) { ans.resize(s.size()+1, 0x3f3f3f3f); for(string a : dictionary) mp[a] = true; ans[s.size() - 1] = !mp[string(1, s.back())]; ans[s.size()] = 0; for(int i = s.size() - 2; i \u003e= 0; --i){ for(int j = 1; j \u003c= s.size() - i; ++j) { string tmp = s.substr(i, j); ans[i] = min(ans[i], (mp[tmp]?0:j) + ans[i+j]); } } return ans[0]; } }; ","date":"2023-09-02","objectID":"/en/posts/lc/medium/2707_extra_characters_in_a_string/:0:0","tags":["dp","hash"],"title":"2707. Extra Characters in a String","uri":"/en/posts/lc/medium/2707_extra_characters_in_a_string/"},{"categories":["leetcode hard"],"content":"my solution","date":"2023-08-31","objectID":"/en/posts/lc/hard/1326_minimum-number_of_taps_to_open_to_water_a_garden/","tags":["dp"],"title":"1326. Minimum Number of Taps to Open to Water a Garden","uri":"/en/posts/lc/hard/1326_minimum-number_of_taps_to_open_to_water_a_garden/"},{"categories":["leetcode hard"],"content":"https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/ https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/submissions/1036407008/ class Solution { public: int minTaps(int n, vector\u003cint\u003e\u0026 ranges) { vector\u003cint\u003e dp(n + 1, 0x3f3f3f3f); dp[0] = 0; for(int i = 0; i \u003c ranges.size(); ++i) { int l = max(0, i - ranges[i]); int r = min(n, i + ranges[i]); for(int j = l; j \u003c= r; ++j) { dp[j] = min(dp[j], dp[l] + 1); } } int ans = 0; for(int i = 0; i \u003c= n; ++i) { if(dp[i] == 0x3f3f3f3f) { return -1; } ans = max(ans, dp[i]); } return ans; } }; ","date":"2023-08-31","objectID":"/en/posts/lc/hard/1326_minimum-number_of_taps_to_open_to_water_a_garden/:0:0","tags":["dp"],"title":"1326. Minimum Number of Taps to Open to Water a Garden","uri":"/en/posts/lc/hard/1326_minimum-number_of_taps_to_open_to_water_a_garden/"},{"categories":["leetcode hard"],"content":"my solution","date":"2023-08-30","objectID":"/en/posts/lc/hard/2366_minimum_replacements_to_sort_the_array/","tags":["math"],"title":"2366. Minimum Replacements to Sort the Array","uri":"/en/posts/lc/hard/2366_minimum_replacements_to_sort_the_array/"},{"categories":["leetcode hard"],"content":"https://leetcode.com/problems/minimum-replacements-to-sort-the-array/description/ https://leetcode.com/problems/minimum-replacements-to-sort-the-array/submissions/1035547342/ class Solution { public: long long minimumReplacement(vector\u003cint\u003e\u0026 nums) { long long ans = 0; int Max = nums.back(); for(int i = nums.size() - 2; i \u003e= 0; --i) { //cout \u003c\u003c i \u003c\u003c \" max = \" \u003c\u003c Max \u003c\u003c \" num = \" \u003c\u003c nums[i] \u003c\u003c endl; if(nums[i] \u003c= Max) { Max = nums[i]; continue; } int divisor = nums[i]; int dividend = Max; int mod = divisor % dividend; int quotient = divisor / dividend; if(mod == 0) { ans += quotient - 1; continue; } ans += quotient; // binary search to find max Max int l = mod, r = Max; while(l \u003c= r) { int mid = (l + r) \u003e\u003e 1; int gap = mid - mod; int times = gap / quotient; if(gap % quotient != 0) { times++; } if(mid \u003e dividend - times) r = mid - 1; else Max = mid, l = mid + 1; } } return ans; } }; // 11 5 //3 3 5 | 5 11 =\u003e 6 5 =\u003e 3 3 5 // 16 5 //4 4 4 4 | 5 16 =\u003e 12 4 =\u003e 8 4 4 =\u003e 4 4 4 4 // 21 5 //4 4 4 4 5 | 5 21 =\u003e 16 5 =\u003e 12 4 5 =\u003e 8 4 4 5 =\u003e 4 4 4 4 5 // 26 5 //4 4 4 4 5 5 | 5 // ...... ","date":"2023-08-30","objectID":"/en/posts/lc/hard/2366_minimum_replacements_to_sort_the_array/:0:0","tags":["math"],"title":"2366. Minimum Replacements to Sort the Array","uri":"/en/posts/lc/hard/2366_minimum_replacements_to_sort_the_array/"},{"categories":["lib"],"content":"c++ lib or usage, which I hardly used but seen, because I don't know...","date":"2023-08-30","objectID":"/en/posts/lib-or-special-usage/c++/","tags":["c++"],"title":"c++ lib or usage, which I hardly used but seen","uri":"/en/posts/lib-or-special-usage/c++/"},{"categories":["lib"],"content":"cstdlib ","date":"2023-08-30","objectID":"/en/posts/lib-or-special-usage/c++/:1:0","tags":["c++"],"title":"c++ lib or usage, which I hardly used but seen","uri":"/en/posts/lib-or-special-usage/c++/"},{"categories":["lib"],"content":"div div_t div(int numer, int denom); ldiv_t div(long int numer, long int denom); lldiv_t div (long long int numer, long long int denom); Returns the integral quotient and remainder of the division of numer by denom ( numer/denom ) as a structure of type div_t, ldiv_t or lldiv_t, which has two members: quot and rem. Only int version for c /* div example */ #include \u003cstdio.h\u003e /* printf */ #include \u003cstdlib.h\u003e /* div, div_t */ int main () { div_t divresult; divresult = div (38,5); printf (\"38 div 5 =\u003e %d, remainder %d.\\n\", divresult.quot, divresult.rem); return 0; } //output: 38 div 5 =\u003e 7, remainder 3. faster used: auto [p, r] = div(38, 5); auto [quotient, remainder] = div(divisor, dividend); ","date":"2023-08-30","objectID":"/en/posts/lib-or-special-usage/c++/:1:1","tags":["c++"],"title":"c++ lib or usage, which I hardly used but seen","uri":"/en/posts/lib-or-special-usage/c++/"},{"categories":["lib"],"content":"isdigit int isdigit ( int c ); Checks whether c is a decimal digit character. Decimal digits are any of: 0 1 2 3 4 5 6 7 8 9 /* isdigit example */ #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cctype.h\u003e int main () { char str[]=\"1776ad\"; int year; if (isdigit(str[0])) { year = atoi (str); printf (\"The year that followed %d was %d.\\n\",year,year+1); } return 0; } //output: The year that followed 1776 was 1777 ","date":"2023-08-30","objectID":"/en/posts/lib-or-special-usage/c++/:1:2","tags":["c++"],"title":"c++ lib or usage, which I hardly used but seen","uri":"/en/posts/lib-or-special-usage/c++/"},{"categories":["lib"],"content":"lambda 在 C++ 中，lambda 表达式的捕获子句（capture clause）可以以多种方式指定，以决定 lambda 函数体可以访问哪些外部变量以及如何访问它们。以下是一些常见的捕获子句表达： 按值捕获（Capture by value）: [=]: 捕获所有外部变量的值。 [var]: 仅通过值捕获单个变量 var。 int x = 10; auto lambda1 = [=] { return x + 10; }; // x 通过值捕获 auto lambda2 = [x] { return x + 10; }; // x 通过值捕获 按引用捕获（Capture by reference）: [\u0026]: 捕获所有外部变量的引用。 [\u0026var]: 仅通过引用捕获单个变量 var。 int x = 10; auto lambda1 = [\u0026] { x += 10; }; // x 通过引用捕获 auto lambda2 = [\u0026x] { x += 10; }; // x 通过引用捕获 混合捕获（Mixed capture）: [\u0026, var]: 通过引用捕获所有变量，但通过值捕获 var。 [=, \u0026var]: 通过值捕获所有变量，但通过引用捕获 var。 int x = 10, y = 20; auto lambda1 = [\u0026, x] { return x + y; }; // x 通过值捕获，y 通过引用捕获 auto lambda2 = [=, \u0026y] { return x + y; }; // x 通过值捕获，y 通过引用捕获 无捕获（No capture）: []: 不捕获任何外部变量。 auto lambda = [] { return 10; }; 初始化捕获（Init capture）:（自 C++14 起） [new_var = expr]: 在捕获子句中初始化一个新变量。 int x = 10; auto lambda = [y = x + 10] { return y; }; // y 是一个新变量，值为 20 通过适当地选择捕获子句，你可以控制 lambda 函数体对外部变量的访问以及如何访问它们。 ","date":"2023-08-30","objectID":"/en/posts/lib-or-special-usage/c++/:2:0","tags":["c++"],"title":"c++ lib or usage, which I hardly used but seen","uri":"/en/posts/lib-or-special-usage/c++/"},{"categories":["leetcode hard"],"content":"my solution","date":"2023-08-27","objectID":"/en/posts/lc/hard/0403_frog_jump/","tags":["priority_queue","unordered_map"],"title":"403. Frog Jump","uri":"/en/posts/lc/hard/0403_frog_jump/"},{"categories":["leetcode hard"],"content":"https://leetcode.com/problems/frog-jump/ https://leetcode.com/problems/frog-jump/submissions/1032720945/ class Solution { public: bool check(unordered_map\u003cint, bool\u003e\u0026 exist, unordered_map\u003cint, unordered_map\u003cint, bool\u003e\u003e \u0026inq, int lastStone, int nextStone, int jumpUnits) { if(inq[nextStone][jumpUnits]) return false; if(nextStone \u003e lastStone) return false; if(!exist[nextStone]) return false; return true; } bool canCross(vector\u003cint\u003e\u0026 stones) { if(stones == (vector\u003cint\u003e){0,1}) { return true; } int n = stones.size(); if(stones.back() \u003e (n * (1 + n - 1) / 2)) { return false; } unordered_map\u003cint, bool\u003e exist; for(int i : stones) exist[i] = true; priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, less\u003cpair\u003cint, int\u003e\u003e\u003e q; unordered_map\u003cint, unordered_map\u003cint, bool\u003e\u003e inq; if(stones[1] != 1) { return false; } q.push(pair(1, 1)); while(!q.empty()) { auto t = q.top(); q.pop(); int nx = t.first + t.second; if(nx == stones.back()) return true; if(check(exist, inq, stones.back(), nx, t.second)) inq[nx][t.second] = true, q.push(pair(nx, t.second)); nx = t.first + t.second + 1; if(nx == stones.back()) return true; if(check(exist, inq, stones.back(), nx, t.second+1)) inq[nx][t.second+1] = true, q.push(pair(nx, t.second+1)); if(t.second != 1) { nx = t.first + t.second - 1; if(nx == stones.back()) return true; if(check(exist, inq, stones.back(), nx, t.second-1)) inq[nx][t.second - 1] = true, q.push(pair(nx, t.second -1)); } } return false; } }; ","date":"2023-08-27","objectID":"/en/posts/lc/hard/0403_frog_jump/:0:0","tags":["priority_queue","unordered_map"],"title":"403. Frog Jump","uri":"/en/posts/lc/hard/0403_frog_jump/"},{"categories":["leetcode hard"],"content":"my solution","date":"2023-08-23","objectID":"/en/posts/lc/hard/0068_text_justification/","tags":["simulation","string","array"],"title":"68. Text Justification","uri":"/en/posts/lc/hard/0068_text_justification/"},{"categories":["leetcode hard"],"content":"https://leetcode.com/problems/text-justification/ https://leetcode.com/problems/text-justification/submissions/1030637814/ class Solution { public: vector\u003cstring\u003e fullJustify(vector\u003cstring\u003e\u0026 words, int maxWidth) { vector\u003cstring\u003e ans; for(int i = 0; i \u003c words.size(); ){ string tans = \"\"; int j = i; while(j != words.size() \u0026\u0026 tans.size() + words[j].size() \u003c= maxWidth) { tans += words[j]; if(tans.size() != maxWidth) tans += \" \"; j++; } if(j == words.size()) { ans.push_back(tans + string(maxWidth - tans.size(), ' ')); } else { ans.push_back(rerrange(tans, maxWidth)); } i = j; } return ans; } inline string rerrange(string s, int maxWidth) { int space = 0; vector\u003cstring\u003e split; string ts = \"\"; for(auto c : s) { if(c == ' ') space++, split.push_back(ts), ts = \"\"; else ts += c; } if(ts != \"\") split.push_back(ts); if(split.size() == 1) { return s + string(maxWidth - s.size(), ' '); } int extraSpace = maxWidth - s.size() + space; int mod = extraSpace % (split.size() - 1); int dev = extraSpace / (split.size() - 1); s = \"\"; for(int i = 0; i \u003c split.size() - 1; ++i) { s += split[i]; if(mod != 0) s += string(dev + 1, ' '), mod--; else s += string(dev, ' '); } s += split.back(); return s; } }; ","date":"2023-08-23","objectID":"/en/posts/lc/hard/0068_text_justification/:0:0","tags":["simulation","string","array"],"title":"68. Text Justification","uri":"/en/posts/lc/hard/0068_text_justification/"},{"categories":["leetcode hard"],"content":"my solution","date":"2023-08-16","objectID":"/en/posts/lc/hard/0239_sliding_window_maximum/","tags":["priority_queue","sliding window"],"title":"239. Sliding Window Maximum","uri":"/en/posts/lc/hard/0239_sliding_window_maximum/"},{"categories":["leetcode hard"],"content":"https://leetcode.com/problems/sliding-window-maximum/ https://leetcode.com/problems/sliding-window-maximum/submissions/1022554836/ class Solution { public: vector\u003cint\u003e maxSlidingWindow(vector\u003cint\u003e\u0026 nums, int k) { priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint,int\u003e\u003e, less\u003cpair\u003cint,int\u003e\u003e\u003e q; for(int i = 0; i \u003c k; ++i) { q.push(pair(nums[i],i)); } vector\u003cint\u003e ans; ans.push_back(q.top().first); for(int i = k; i \u003c nums.size(); ++i) { q.push(pair(nums[i], i)); auto t = q.top(); while(t.second \u003c= i - k) { q.pop(); t = q.top(); } ans.push_back(q.top().first); } return ans; } }; ","date":"2023-08-16","objectID":"/en/posts/lc/hard/0239_sliding_window_maximum/:0:0","tags":["priority_queue","sliding window"],"title":"239. Sliding Window Maximum","uri":"/en/posts/lc/hard/0239_sliding_window_maximum/"},{"categories":null,"content":"Q2 ","date":"2022-11-13","objectID":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/:1:0","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Tutorial An easy dp problem, for dp[i], means how many good string of length i. Init dp[zero] = 1, dp[one] = 1 (if one == zero, then dp[one] = 2); So dp[i] = dp[i - zero] + dp[i - one]. After calculate all dp, sum up dp[low] to dp[high]. Accepted Code class Solution { public: long long dp[100005]; int countGoodStrings(int low, int high, int zero, int one) { memset(dp, 0, sizeof(dp)); dp[zero]++; dp[one]++; for(int i = min(zero, one); i \u003c= high; ++i){ if(i \u003e zero) dp[i] += dp[i - zero]; if(i \u003e one) dp[i] += dp[i - one]; dp[i] %= 1000000007; } long long ans = 0; for(int i = low; i \u003c= high; ++i){ ans += dp[i]; ans %= 1000000007; } return ans; } }; ","date":"2022-11-13","objectID":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/:1:1","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Q3 ","date":"2022-11-13","objectID":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/:2:0","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Tutorial First, from root 0, bfs all tree to find where bob is. Storage the parent node of every node. Secondly, from Bob Node, Stroage the time that bob will visit from bob node to root. Last, from node 0, calculate alice’s maximum income to all leaf. Accepted Code class Solution { public: int bobVisTime[100005]; vector\u003cint\u003e to[100005]; int dp[100005]; map\u003cint, int\u003e par; int res; int mostProfitablePath(vector\u003cvector\u003cint\u003e\u003e\u0026 edges, int bob, vector\u003cint\u003e\u0026 amount) { memset(bobVisTime, 0x3f3f3f3f, sizeof(bobVisTime)); memset(dp, 0, sizeof(dp)); res = INT_MIN; for(auto i : edges){ int a = i[0], b = i[1]; to[a].push_back(b); to[b].push_back(a); } fillBobVisTime(bob); dfs(0, 0, -1, 0, amount); return res; } void dfs(int a, int t, int p, int ans, const vector\u003cint\u003e \u0026amount){ //printf(\"a = %d, t = %d, ans = %d, bobVisTime = %d\\n\", a, t, ans, bobVisTime[a]); if(t == bobVisTime[a]){ //同时到达 ans += amount[a] / 2; } else if(bobVisTime[a] \u003e t){ //alice先到 ans += amount[a]; } else{ // bob先到 ans += 0; } for(int i : to[a]){ if(i != p) dfs(i, t + 1, a, ans, amount); } if(to[a].size() == 1 \u0026\u0026 a != 0){ //leaf //printf(\"a = %d\\n\", a); res = max(res, ans); } return; } void fillBobVisTime(int b){ queue\u003cpair\u003cint, int\u003e\u003e q; q.push({0, 0}); while(!q.empty()){ pair\u003cint, int\u003e t = q.front(); q.pop(); for(int i : to[t.first]){ if(bobVisTime[i] != 0x3f3f3f3f) continue; bobVisTime[i] = t.second + 1; par[i] = t.first; q.push({i, t.second + 1}); } } memset(bobVisTime, 0x3f3f3f3f, sizeof(bobVisTime)); int cnt = 0; while(b != 0){ bobVisTime[b] = cnt++; b = par[b]; } bobVisTime[0] = cnt; return; } }; ","date":"2022-11-13","objectID":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/:2:1","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Q4 ","date":"2022-11-13","objectID":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/:3:0","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Tutorial We define an array sumL of length 1e4. sumL[11] mean the length of all string: “1”, “2”, “3”, …… , “10”, “11”. So if there is an valid answer, we conbine all the splited string into one string, the length of the string is: message.length + sumL[b] + b * string_of_b.length + b * 3. If we don’t ignore the last part, make all part’s length equal to limit. The check will be very easy: limit * b == message.length + sumL[b] + b * string_of_b.length + b * 3. If we could find some b(from 1 to 1e4) satisfied this equation, make it to be the answer. But now, we can except the last part of message, whose length can be at most limit. So we just change the equation to be an inequality: limit * b - message.length + sumL[b] + b * string_of_b.length + b * 3 \u003c limit. If we could find a b satisfied this inequality, we find the answer. Accepted Code class Solution { public: int sumL[10005]; vector\u003cstring\u003e splitMessage(string message, int limit) { memset(sumL, 0, sizeof(sumL)); for(int i = 1; i \u003c= 10000; ++i){ sumL[i] = sumL[i - 1] + tos(i).size(); } for(int i = 1; i \u003c= 10000; ++i){ if(check(i, limit, message.size())){ return del(i, message, limit); } } return {}; } inline vector\u003cstring\u003e del(int b, string message, int limit){ vector\u003cstring\u003e res; int idx = 0; string bs = tos(b); int blen = bs.size(); for(int i = 1; i \u003c= b; ++i){ string tres = \"\"; string as = tos(i); int les = limit - 3 - blen - as.size(); tres = message.substr(idx, les) + \"\u003c\" + as + \"/\" + bs + \"\u003e\"; idx += les; res.push_back(tres); } return res; } inline bool check(int b, int limit, int mL){ if(limit * b - (mL + b * 3 + b * tos(b).size() + sumL[b]) \u003c limit){ return true; } return false; } inline string tos(int n){ string res = \"\"; while(n){ res += char(n % 10 + '0'); n /= 10; } reverse(res.begin(), res.end()); return res; } }; ","date":"2022-11-13","objectID":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/:3:1","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/lc-contest/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"If you get any problem of my code or you find something wrong, just leave a comment or contact with me, I’ll response you as fast as I can if I see it. If this tutorial helps you well, you can subscribe my website, every time I update any Tutorial, I’ll send an email to all subscribers. ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:0:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-31 766. Toeplitz Matrix Difficulty: Easy Accepted Code class Solution { public: bool isToeplitzMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { vector\u003cint\u003e n[int(matrix.size() + matrix[0].size() - 1)]; int beginIdx = 0; for(int i = matrix.size() - 1; i \u003e= 0; --i){ int j = beginIdx; for(int k : matrix[i]) n[j++].push_back(k); beginIdx++; } for(auto i : n) { int j = i[0]; for(int k : i) if(k != j) return false; } return true; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:1:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-30 1293. Shortest Path in a Grid with Obstacles Elimination Difficulty: Hard ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:2:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial BFS Accepted Code( T/ M : 68.41%/82.45%) class Solution { public: int shortestPath(vector\u003cvector\u003cint\u003e\u003e\u0026 grid, int k) { int n = grid.size(), m = grid[0].size(); //define n, m as problem describe if(n == 1 \u0026\u0026 m == 1) return 0; queue\u003cpair\u003cpair\u003cint, int\u003e, pair\u003cint, int\u003e\u003e\u003e q; //( (x, y), (k, step) ) //current position(x, y), can elemate k obstacle, have moved step times; q.push({{0,0}, {k, 0}}); //start point int dx[] = {-1, 0, 1, 0}; //direction int dy[] = {0, -1, 0, 1}; //direction map\u003cpair\u003cint, int\u003e, int\u003e visit; for(int i = 0; i \u003c n; ++i) for(int j = 0; j \u003c m; ++j) visit[{i,j}] = -1; while(!q.empty()){ auto t = q.front(); q.pop(); for(int i = 0; i \u003c 4; ++i){ //traverse four directions int nx = t.first.first + dx[i]; //next x int ny = t.first.second + dy[i]; //next y int nk = t.second.first; //next k; //check is (nx, ny) end point; if(nx == n - 1 \u0026\u0026 ny == m - 1) return t.second.second + 1; // reach end point //check next position whether is valid or not if(nx \u003c 0 || nx \u003e= n || ny \u003c 0 || ny \u003e= m) continue; //out of grid; if(grid[nx][ny] == 1 \u0026\u0026 t.second.first == 0) continue; //next step is obstacle, but cannot elemate any obstacle now; if(grid[nx][ny]) nk--; if(visit[{nx, ny}] != -1 \u0026\u0026 visit[{nx, ny}] \u003e= nk) continue; visit[{nx, ny}] = nk; //move; q.push({{nx, ny}, {nk, t.second.second + 1}}); } } return -1; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:2:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-29 2136. Earliest Possible Day of Full Bloom Difficulty: Hard ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:3:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Obviously we need sum of plantTime to plant all the flowers. And After plant, we just need to wait all flowers grown-up. Look at the example 1, after we plant all flower, we need to wait third flower to grow. So plant the min grow time flower last could be better. So we sort all the flower by grow time in decreasing order. But there are some special cases. If we change example 1 to: plantTime = [4, 3], growTime = [6, 1]. the answer will be 4 + 6. First we use 4 days to plant 1st flower, and then we take 3 days to plant 2nd flower, and 2nd flower takes 1 days to grow. But 1st flower need 6 days to grow, while 1st flower is growing, we can plant 2nd flower and wait it grwon-up. So the answer only depends on the 1st flower. Accepted Code class Solution { public: int earliestFullBloom(vector\u003cint\u003e\u0026 plantTime, vector\u003cint\u003e\u0026 growTime) { int all = 0, ans = 0; int n = plantTime.size(); vector\u003cpair\u003cint, int\u003e\u003e pg; for(int i = 0; i \u003c n; ++i) pg.push_back({plantTime[i], growTime[i]}); sort(pg.begin(), pg.end(), [](pair\u003cint, int\u003e a, pair\u003cint, int\u003e b){ return a.second \u003e b.second; }); for(pair\u003cint, int\u003e it : pg){ all += it.first; ans = max(ans, all + it.second); // in case the special case, record the longest time to grow current flower. } return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:3:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-28 49. Group Anagrams Difficulty: Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:4:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial If two strings are in the same group, after sorting two strings, they will be the same string. It is easy to understand, because two strings have the same letter, and times of each letters’ appera are the same also. So just traverse all the string, use unordered_map or map to record the same string after sorting. Accepted Code:(T / M : 86.78% / 56.57%) class Solution { public: vector\u003cvector\u003cstring\u003e\u003e groupAnagrams(vector\u003cstring\u003e\u0026 strs) { unordered_map\u003cstring, vector\u003cstring\u003e\u003e pos; int cnt = 0; for(string s: strs){ sort(s.begin(), s.end()); pos[s].push_back(strs[cnt++]); } vector\u003cvector\u003cstring\u003e\u003eans; for(auto it : pos) ans.push_back(it.second); return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:4:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-27 835. Image Overlap Difficulty: Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:5:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial For the answer, we move ans step for every 1 in image1. For every 1 in image1, we make enumerate the last position in image2, make two 1 overlap, check the step, most step will be the ans. Because if we move ans steps, most 1 will overlap. Accepted Code: class Solution { public: int largestOverlap(vector\u003cvector\u003cint\u003e\u003e\u0026 img1, vector\u003cvector\u003cint\u003e\u003e\u0026 img2) { int n = img1.size(); vector\u003cpair\u003cint, int\u003e \u003e vp1, vp2; for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ if(img1[i][j]) vp1.push_back({i,j}); if(img2[i][j]) vp2.push_back({i,j}); } } int ans = 0; map\u003cpair\u003cint, int\u003e, int\u003e mp; for(auto it1 : vp1){ for(auto it2 : vp2){ int a = it1.first - it2.first; int b = it1.second - it2.second; mp[{a, b}]++; ans = max(ans, mp[{a, b}]); } } return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:5:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-26 523. Continuous Subarray Sum Difficulty: Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:6:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial If sum[1 ~ l] % k == 0 \u0026\u0026 sum[1 ~ r] % k == 0, sum[l ~ r] % k == 0, this judgement is valid when r - l \u003e 1. Accepted Code class Solution { public: bool checkSubarraySum(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e mp; int sum = 0; for(int i = 0; i \u003c nums.size(); ++i){ sum += nums[i]; sum %= k; if(mp.count(sum) != 0 \u0026\u0026 i - mp[sum] \u003e 1 || sum == 0 \u0026\u0026 i \u003e 0) return true; else if(mp.count(sum) == 0) mp[sum] = i; } return false; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:6:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-24 1239. Maximum Length of a Concatenated String with Unique Characters Difficulty: Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:7:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Use Dfs to enumerate all concatenated string, check whether is valid. Accepted Code: (T/M : 78.69% / 79.31%) class Solution { public: int maxLength(vector\u003cstring\u003e\u0026 arr) { return dfs(0, arr, \"\"); } int dfs(int idx, vector\u003cstring\u003e \u0026arr, string cur){ if(idx == arr.size()){ return cur.size(); } int ans = 0; for(int i = idx; i \u003c arr.size(); ++i){ string nxt = cur + arr[i]; if(check(nxt)){ ans = max(ans, int(nxt.size())); ans = max(ans, dfs(i + 1, arr, nxt)); } } return ans; } bool check(string s){ if(s.size() \u003e 26) return false; bool vis[26] = {false}; for(char i : s){ if(vis[i - 'a']) return false; vis[i - 'a'] = true; } return true; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:7:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-23 645. Set Mismatch Difficulty: Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:8:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial No Tutorial. Accepted Code class Solution { public: vector\u003cint\u003e findErrorNums(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); bool vis[10005]; memset(vis, false, sizeof(vis)); vector\u003cint\u003e res; for(int i : nums){ if(vis[i]) res.push_back(i); vis[i] = true; } for(int i = 1; i \u003c= n; ++i){ if(vis[i] == false){ res.push_back(i); return res; } } } }; more beautiful code from HERE vector\u003cint\u003e findErrorNums(vector\u003cint\u003e\u0026 nums) { for(int i = 0; i\u003cnums.size(); i++){ while(nums[i] != nums[nums[i] - 1])swap(nums[i], nums[nums[i] - 1]); } for(int i = 0; i\u003cnums.size() ; i++){ if(nums[i] != i + 1)return {nums[i], i + 1}; } } ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:8:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-22 76. Minimum Window Substring Difficulty: Hard ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:9:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Use two pointer。 I’m playing mahjong, I’ll write later First, use two pointer to index a window, which include all the letters in t. Second, try to make the window shorter by moving its left side. When shorting the window, make window always be valid. After second step, compare valid window length with current answer. If shorter, update answer. Third, continue to move window’s right side, util window include all letters in t, then repeat from second step. Accepted Code（T/M：80.58%， 94.27%） class Solution { public: string minWindow(string s, string t) { if(s.size() \u003c t.size()) return \"\"; int cnt[130] = {0}; bool exist[130] = {false}; for(char c: t) cnt[c]++, exist[c] = true; int minl = -1, minr = 1000000; int l = 0, r = 0, tn = t.size(); while(r \u003c s.size()){ if(exist[s[r]]){ if(--cnt[s[r]] \u003e= 0) tn--; if(tn == 0){ // current [l, r] include all letters in t. while(tn == 0){ //step 2nd. while(l \u003c= r \u0026\u0026 !exist[s[l]]) ++l; //move left side of the window. if(++cnt[s[l]] \u003e 0) ++tn; //if after move, window invalid, break current loop. ++l; } if(minr - minl \u003e r - l) minr = r, minl = l - 1; // compare with answer } } ++r; // step 3rd. } if(minl == -1) return \"\"; s = s.substr(minl, minr - minl + 1); return s; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:9:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-21 219. Contains Duplicate II Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:10:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Traverse nums, record all number last index in traversal, compare distance of current number index and last index with k, if valid, return true, else update last index to current index. Accepted Code class Solution { public: bool containsNearbyDuplicate(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e lastPos; for(int i = 0; i \u003c nums.size(); ++i){ if(lastPos[nums[i]] == 0) lastPos[nums[i]] = i + 1; else{ if(i + 1 - lastPos[nums[i]] \u003c= k) return true; lastPos[nums[i]] = i + 1; } } return false; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:10:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-19 692. Top K Frequent Words Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:11:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Count the number of occurrences of every word. Make word and its count be an struct, sort the struct list, and select top k frequent words. Accepted Code (T/M : 27.39%/39.56%) class Solution { public: unordered_map\u003cstring, int\u003e count; struct Word{ string w; int count; friend bool operator \u003c (Word a, Word b){ if(a.count != b.count) return a.count \u003e b.count; return a.w \u003c b.w; } }; vector\u003cstring\u003e topKFrequent(vector\u003cstring\u003e\u0026 words, int k) { for(string s : words) count[s]++; vector\u003cWord\u003e s; for(auto it: count){ s.push_back((Word){it.first, it.second}); } sort(s.begin(), s.end()); vector\u003cstring\u003e res; for(int i = 0; i \u003c k; ++i) res.push_back(s[i].w); return res; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:11:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-18 38. Count and Say Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:12:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial For countAndSay(n), calculate countAndSay(n - 1) til n == 1 by DFS. Accepted Code(T/M : 66%/89.76%) class Solution { public: string countAndSay(int n) { if(n == 1) return \"1\"; string pre = countAndSay(n - 1); int cnt = 1; string cur = \"\"; for(int i = 0; i \u003c pre.size() - 1; ++i){ if(pre[i] == pre[i + 1]){ cnt++; } else{ cur += getNum(cnt); cur += pre[i]; cnt = 1; } } cur += getNum(cnt); cur += pre[pre.size() - 1]; return cur; } string getNum(int n){ string res = \"\"; while(n){ res += char(n % 10 + '0'); n /= 10; } reverse(res.begin(), res.end()); return res; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:12:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-17 1832. Check if the Sentence Is Pangram Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:13:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Accepted Code（T/M ：80.43%/100%） class Solution { public: bool checkIfPangram(string sentence) { int cnt = 0; for(char c : sentence) cnt |= (1 \u003c\u003c (c - 'a')); return cnt == 67108863; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:13:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-16 1335. Minimum Difficulty of a Job Schedule ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:14:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial It a very classic dp problem: split an array to dsubarrarys, minimize the sum of all subarray’s maximum number. Usually, we use two-dimensional array dp to solve this kind of problem. dp[idx][d], idx represents current index, d represents we need to split the remaining arrary [idx, n] to d subarrarys. Enumerate the endpoints of first subarrary from idx to n, calculate best dp[endPoint + 1][d - 1]. With dfs, the last state we need to calculate is: get one subarray, make the max number minimum(dp[x][1]). When dfs returns, we could get dp[x - 1][2]. At last, we get dp[0][d], which is our answer. To be clear: dp[idx][d] = min(dp[idx + 1][d - 1], dp[idx + 2][d - 1], dp[idx +3][d - 1], …… , dp[n][d - 1]). So we set invalid dp state to infinite to avoid affecting dp[idx][d]. Accepted Code(T/M : 88.85%/99.15%) class Solution { public: int dp[305][15]; int dfs(int idx, int d, const vector\u003cint\u003e \u0026job){ if(dp[idx][d] != -1) return dp[idx][d]; // have been calculated. if(idx == job.size() \u0026\u0026 d == 0) return 0; // dp[n][0] = 0 if(idx == job.size() || d == 0) return 0x3f3f3f3f; //invalid, d is not 0, but job is splited over or remain d days to split, but no job. if(job.size() - idx \u003c d) return 0x3f3f3f3f; //invalid, cannot split job[idx :] to d subarrays. int m = job[idx], ans = 0x3f3f3f3f; for(int i = idx; i \u003c job.size(); ++i){ m = max(m, job[i]); ans = min(ans, m + dfs(i + 1, d - 1, job)); // dp[idx][d] = maxJobDiff(idx, i) + dp[i + 1][d - 1]; } dp[idx][d] = ans; return ans; } int minDifficulty(vector\u003cint\u003e\u0026 job, int d) { memset(dp, -1, sizeof(dp)); if(job.size() \u003c d) return -1; return dfs(0, d, job); } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:14:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-15 1531. String Compression II ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:15:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial https://leetcode.com/problems/string-compression-ii/discuss/756022/C%2B%2B-Top-Down-DP-with-explanation-64ms-short-and-clear Accepted Code class Solution { public: int dp[101][101]; int N; int getCodingLen(int l){ if(l == 1) return 1; if(l \u003c= 9) return 2; if(l \u003c= 99) return 3; return 4; } int dfs(const string \u0026s, int idx, int k){ if(k \u003c 0) return N; //cannot delete any letter, return max len; if(dp[idx][k] != -1) return dp[idx][k]; //have been calculated; if(idx \u003e= N or N - idx \u003c= k) return 0; //delete all remain letters; dp[idx][k] = N; //initiate dp int maxCnt = 0; //declear maxCnt int cnt[26] = {0}; //declear cnt to record each letters count in s[idx] -\u003e s[i]; for(int i = idx; i \u003c N; ++i){ maxCnt = max(maxCnt, ++cnt[s[i] - 'a']); //calculate maxCnt dp[idx][k] = min(dp[idx][k], getCodingLen(maxCnt) + dfs(s, i + 1, k - (i - idx + 1 - maxCnt))); //after delete all letters(most commonly apperaed in s[idx]-\u003es[i]) } return dp[idx][k]; } int getLengthOfOptimalCompression(string s, int k) { N = s.size(); memset(dp, -1, sizeof(dp)); return dfs(s, 0, k); } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:15:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-14 2095. Delete the Middle Node of a Linked List Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:16:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial This type of problem’s most commonly solution is use two pointer, one is move faster than the other. As for this problem, we need to move faster pointer 2 node per time, slower pointer move one by one. Only if the faster pointer could not move anymore, we stop the movement. At that time, the slower pointer is pointing to the previous node of middle node. And then change the next node of current node to be the next next node, the problem solved. Accepted Code (T/M : 99.38%/64.88%) class Solution { public: ListNode* deleteMiddle(ListNode* head) { ListNode *h = head; if(head -\u003e next == nullptr) return nullptr; ListNode *fast = head -\u003e next; while(fast != nullptr \u0026\u0026 fast -\u003e next != nullptr \u0026\u0026 fast -\u003e next -\u003e next != nullptr) { head = head -\u003e next; fast = fast -\u003e next -\u003e next; } head -\u003e next = head -\u003e next -\u003e next; return h; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:16:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-13 237. Delete Node in a Linked List Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:17:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial If We know the head node, we could traverse the linked list, if node-\u003enext-\u003eval == targetValue, then node-\u003enext = node-\u003enext-\u003enext. But now we only know the targetNode we need to remove, so we could’n change the next pointer to remove given node. Cause answer check only check the value in the link list. We can move all the value after give node forward one node, and then, delete the last node. process: 4 -\u003e 5 -\u003e 1 -\u003e 9 4 -\u003e 1 -\u003e 1 -\u003e 9 4 -\u003e 1 -\u003e 9 -\u003e 9 4 -\u003e 1 -\u003e 9 Accepted Code(T/M: 44%/92%) class Solution { public: void deleteNode(ListNode* node) { while(node -\u003e next -\u003e next != nullptr) { node -\u003e val = node -\u003e next -\u003e val; node = node -\u003e next; } node -\u003e val = node -\u003e next -\u003e val; node -\u003e next = nullptr; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:17:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-12 976. Largest Perimeter Triangle Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:18:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial For a triangle, any two vertices’ sum should bigger than remain one. So we sort all the numbers, and from big to small, check the smaller two numbers’ sum whether bigger than the biggest one. If so, this three number can form a triangle. Accepted Code class Solution { public: int largestPerimeter(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); for(int i = nums.size() - 1; i - 2 \u003e= 0; --i){ if(nums[i - 2] + nums[i - 1] \u003c= nums[i]) continue; return nums[i - 2] + nums[i - 1] + nums[i]; } return 0; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:18:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-11 334. Increasing Triplet Subsequence Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:19:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Consider a very easy problem: Give you an array, find two element a and b, required a \u003c b, if exist valid a and b, return true. else return false. To solve this question, we only need one variable a, if current element i smaller than a, assign i to a, else if i bigger than a, return true, after traverse the array, return false. Back to this problem, before we return true(find valid a and b), we need another element c, c is smaller than a. if we could find valid c, the problem will be solved. Now, If we find a valid c before find a and b, remain problem is exactly the same as the easy problem above. The different is, before we update a to be an smaller number, we need to be sure that new a is bigger than c. Accepted Code class Solution { public: bool increasingTriplet(vector\u003cint\u003e\u0026 nums) { if(nums.size() \u003c 3) return false; int c = INT_MAX, a = INT_MAX; for(int i = 0; i \u003c nums.size(); ++i){ if(nums[i] \u003c= c) c = nums[i]; //update c first else if(nums[i] \u003c= a) a = nums[i]; //if nums[i] is bigger than c, but smaller than a, we could update a to nums[i], every time we update a to be a smaller number, the range of valid b is bigger. else return true; } return false; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:19:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-10 1328. Break a Palindrome Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:20:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial First of all, if palindrome’s length is 1, we could not make it not palindromic. Secondly, If palindrome’s length is odd, we could not make it not palindromic by change the letter in the middle. Otherwise, If we change any letter, the palindrome will not palindromic anymore. For purpose, we need to break the palindrome and at the same time make it lexicographically smallest, we only need to change a valid letter(can change the palindromic) to be ‘a’, if we could’n find a valid letter, change the last letter to be ‘b’. Because at that time, all the valid letter is ‘a’, so the last letter must be ‘a’ also. Accepted Code(100%, 45%) class Solution { public: string breakPalindrome(string palindrome) { if(palindrome.size() == 1) return \"\"; bool isEven = !(palindrome.size() % 2); for(int i = 0; i \u003c palindrome.size(); ++i){ if(palindrome[i] != 'a'){ if(!isEven \u0026\u0026 palindrome.size() / 2 == i) continue; palindrome[i] = 'a'; return palindrome; } } palindrome[palindrome.size() - 1] = 'b'; return palindrome; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:20:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-09 653. Two Sum IV - Input is a BST Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:21:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial DFS this BST, and while searching, check whether exist value equal to target - currentRoot-\u003eval. Accepted Code(92.29% / 98.68%) class Solution { public: bool exist[30001]; bool findTarget(TreeNode* root, int k) { if(root == nullptr) return false; if(exist[k - root-\u003eval + 10000] == true) return true; exist[root-\u003eval + 10000] = true; return findTarget(root -\u003e left, k) || findTarget(root-\u003eright, k); } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:21:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-08 16. 3Sum Closest Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:22:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial As we could see, if we use brute force to solve the problem, it need O(n3) time complexity, which is unacceptable. So at least, we need to improve time complexity to O(n2). We consider another easier problem first: give a sorted array, find two numbers in array, which’s sum is closest to target. Because this array is sorted, if we use two pointers, l and r, l = 1, r = array.size(). For every time we move pointer, we could easily know: if move l to l + 1, will make current sum bigger, if move r to r - 1, will make current sum smaller. So if current sum is smaller than target, we should move l to l + 1 to make it bigger, vice versa. And after every time moving, we could check whether current sum is the closet sum to target. This approach’s time complexity is O(n). Back to the origin problem. We only need to enumerate first number, and then the problem we need to solve is just exactly the same with the problem above. All time complexity is O(nlogn + n2). Accepted Code class Solution { public: int threeSumClosest(vector\u003cint\u003e\u0026 nums, int target) { sort(nums.begin(), nums.end()); int ans = nums[0] + nums[1] + nums[2]; int n = nums.size(); for(int i = 0; i \u003c n - 2; ++i){ int l = i + 1, r = n - 1; int tans = nums[i] + nums[l] + nums[r]; while(l \u003c r) { if(check(tans, ans, target, \u0026ans)) ; if(check(tans - nums[r] + nums[r - 1], tans - nums[l] + nums[l + 1], target, \u0026tans)) r--; else l++; } } return ans; } bool check(int n1, int n2, int target, int *ans) { //return true if n1 is closer than n2 to target. if(abs(n1 - target) \u003c abs(n2 - target)) { *ans = n1; return true; } *ans = n2; return false; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:22:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-07 732. My Calendar III ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:23:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial For every event, the range where it contribute to the answer, is [event, end - 1]. So we only need to record all event point, and then traverse all point, calculate current k event. Accepted Code(6%/100%) class MyCalendarThree { public: MyCalendarThree() { } int book(int start, int end) { add(start, end); return check(); } private: vector\u003cint\u003e ev; inline void add(int s, int e){ //be invoked n times; ev.push_back(s); ev.push_back(-e); sort(ev.begin(), ev.end(), [](int a, int b){ //O(nlogn); if(abs(a) == abs(b)) return a \u003c b; // to prevent after sorted, will turn up like: 50, -50 return abs(a) \u003c abs(b); }); return; } inline int check(){ int res = 0, cur = 0; for(int i = 0; i \u003c ev.size(); ++i){ cur += ev[i] \u003c 0 ? -1 : 1; res = max(res, cur); } return res; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:23:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-06 981. Time Based Key-Value Store Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:24:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Read the code Accepted Code class TimeMap { public: TimeMap() { } void set(string key, string value, int timestamp) { mapKey2Time[key].insert(timestamp); kv[key][timestamp] = value; } string get(string key, int timestamp) { auto it = mapKey2Time[key].upper_bound(timestamp); if(it == mapKey2Time[key].begin()) return \"\"; it--; return kv[key][*it]; } private: unordered_map\u003cstring, ::set\u003cint\u003e \u003e mapKey2Time; unordered_map\u003cstring, unordered_map\u003cint, string\u003e\u003e kv; }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:24:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-05 623. Add One Row to Tree Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:25:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Observed this two examles, we could find that, add row in depth is to add two new TreeNode to all node which’s depth is depth - 1. And then, the right new node inherit father’s left subtree, right new node inherit father’s right subtree. So We could Use DFS or BFS to find the target node, which’s depth is depth - 1. Accepted Code With DFS(9.9%/98.26%) class Solution { public: TreeNode* addOneRow(TreeNode* root, int val, int depth) { if(depth == 1) { TreeNode *nRoot = new(TreeNode); nRoot-\u003eval = val; nRoot-\u003eleft = root; return nRoot; } addRow(root, 1, val, depth); return root; } private: void addRow(TreeNode* root, int currentDepth, int val, int depth){ if(root == nullptr) return; if(currentDepth + 1 == depth) { TreeNode *left = new(TreeNode); left-\u003eleft = root-\u003eleft; left-\u003eval = val; TreeNode *right = new(TreeNode); right-\u003eright = root-\u003eright; right-\u003eval = val; root-\u003eleft = left, root-\u003eright = right; return; } addRow(root-\u003eleft, currentDepth+1, val, depth); addRow(root-\u003eright, currentDepth+1, val, depth); return; } }; Accepted Code With BFS(85.7%/16.59%) class Solution { public: TreeNode* addOneRow(TreeNode* root, int val, int depth) { if(depth == 1) { TreeNode *nRoot = new(TreeNode); nRoot-\u003eval = val; nRoot-\u003eleft = root; return nRoot; } NewNode *nroot = new(NewNode); nroot-\u003enode = root; nroot-\u003edep = 1; vector\u003cTreeNode*\u003e targetNode; //all the target depth TreeNode queue\u003cNewNode\u003e q; q.push(*nroot); while(!q.empty()){ NewNode f = q.front(); q.pop(); if(f.dep + 1 == depth) { targetNode.push_back(f.node); } else{ if(f.node-\u003eleft != nullptr){ q.push((NewNode){f.node-\u003eleft, f.dep+1}); } if(f.node-\u003eright != nullptr){ q.push((NewNode){f.node-\u003eright, f.dep+1}); } } } for(int i = 0; i \u003c targetNode.size(); ++i){ TreeNode *r = targetNode[i]; TreeNode *left = new(TreeNode), *right = new(TreeNode); left-\u003eval = right-\u003eval = val; left-\u003eleft = r-\u003eleft; right-\u003eright = r-\u003eright; r-\u003eright = right; r-\u003eleft = left; } return root; } private: struct NewNode{ TreeNode *node; int dep; }; }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:25:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-04 112. Path Sum Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:26:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Nothing to say, read the code. Accepted Code (13ms, 21.6MB) class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { return solve(root, targetSum, 0); } bool solve(TreeNode *root, int t, int c) { if(root == nullptr) return false; if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr) return t == (c + root-\u003eval); return solve(root-\u003eleft, t, c + root-\u003eval) || solve(root-\u003eright, t, c + root-\u003eval); } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:26:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-03 1578. Minimum Time to Make Rope Colorful Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:27:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Obviously, when some balloons have the same color and they are adjcent to each other, we need to remove all the ballon except the neededTime is minimum. So for easily, we can use prioriy_queue to restore all the neededTime of adjcent ballons, and remove the minimum neededTime, then sum the remain neededTime. Accepted Code 1(638 ms(5%), 106.6 MB(5%)) class Solution { public: int minCost(string colors, vector\u003cint\u003e\u0026 neededTime) { int n = colors.size(); int sum = 0; for(int i = 0; i \u003c n - 1; ++i){ if(colors[i] == colors[i + 1]){ priority_queue\u003cint\u003e q; while(i \u003c n - 1 \u0026\u0026 colors[i] == colors[i + 1]) q.push(neededTime[i++]); q.push(neededTime[i]); q.pop(); while(!q.empty()) { sum += q.top(); q.pop(); } } } return sum; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:27:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"First step improvement In fact, we only need to know two variables, the adjcent ballons summation of neededTime and the maximum neededTime. So we don’t really need to use priority_queeu to do that. just calculate this two variables by ourself. First Step Improvement Accepted Code(159 ms(95%), 95.4MB(84%)) class Solution { public: int minCost(string colors, vector\u003cint\u003e\u0026 neededTime) { int ans = 0; int l = 0, r = 1; int sum = 0, maxT = 0; int n = colors.size(); if(n == 1) return 0; while(r \u003c n){ maxT = neededTime[l]; sum = maxT; while(colors[l] == colors[r]){ maxT = max(maxT, neededTime[r]); sum += neededTime[r]; r++; } if(r - l == 1){ //eg: abc, l = 0, r = 1, don't need to remove any ballon. ++l; ++r; //move to next ballon; } else { //eg: aabaa, [-1,2,3,4,1]; l = 0, r = 2, sum = 1 + 2 = 3, maxT = 2, need to remove 1 ballon. ans += sum - maxT; l = r++; } } return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:27:2","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Second step improvement This step is not to improve the efficiency of the code. Just improve the code beauty. We can learn from the idea of bubble-sorting, make the maximum neededTime to the last position, and in process, we sum the other neededTime. Second step Accepted Code(156 ms(96%), 95.5 MB(50%)) class Solution { public: int minCost(string colors, vector\u003cint\u003e\u0026 neededTime) { int ans = 0; int n = colors.size(); for (int i = 0; i + 1 \u003c colors.size(); i++) { if (colors[i] == colors[i + 1]) { if (neededTime[i] \u003e neededTime[i + 1]) { ans += neededTime[i + 1]; //add smaller time neededTime[i + 1] = neededTime[i]; //bubble; } else ans += neededTime[i]; } } return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:27:3","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-02 1155. Number of Dice Rolls With Target Sum Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:28:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Obviously we need to us dp to solve this problem. Define a two-dimensional array dp, dp[i][j] means, the count of ways that if we use i dice to get sum j. So the transfer equation of dp[i][j] is: the sum of the dp[i - 1][j - k], k means ith dice’s number. The equation’s meaning is if we use i dice, and we have know all count of ways that if we use i-1 dice to get targets, current dice face-up number is k, so the dp[i][j] must be dp[i - 1][j - k]’s sum. C++ Accepted Code(43ms, 6MB) class Solution { public: int dp[31][1001]; // dp[i][j] = x, used i dices, get sum j, have x ways; int mod; int numRollsToTarget(int n, int k, int target) { mod = 1e9 + 7; dp[0][0] = 1; for(int i = 1; i \u003c= n; ++i){ for(int x = 1; x \u003c= target; ++x){ for(int j = 1; j \u003c= k; ++j){ if(j \u003e x) break; //invalid; dp[i][x] += dp[i - 1][x - j]; dp[i][x] %= mod; } } } return dp[n][target]; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:28:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Improve1: As we can see, In above code, we only use dp[i] and dp[i - 1], this 2 array, so we can optimize other space, only use dp[2][target]. Detail to see code below. C++ Accepted Code(51ms, 5.9MB(99%)) class Solution { public: int dp[2][1001]; int mod; int numRollsToTarget(int n, int k, int target) { mod = 1e9 + 7; dp[0][0] = 1; for(int i = 1; i \u003c= n; ++i){ for(int x = 1; x \u003c= target; ++x){ for(int j = 1; j \u003c= k; ++j){ if(j \u003e x) break; //invalid; dp[i \u0026 1][x] += dp[!(i \u0026 1)][x - j]; dp[i \u0026 1][x] %= mod; } } memset(dp[!(i \u0026 1)], 0, sizeof(dp[!(i \u0026 1)])); } return dp[n \u0026 1][target]; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:28:2","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Improve2: In the third loop, we calculate dp[i \u0026 1][x] asdp[i \u0026 1][x] += dp[!(i\u00261)][x - j], is very similar to another thing: the prefix sum. If we record the dp[i][x - 1] + dp[i][x - 2] + ...... + dp[i][x - k] as sum[i][x - 1], we could calculate dp[i + 1][x] which is the sum of dp[i][x- 1], dp[i][x - 2], ......, dp[x - k] very fast. So the improve way is to calculate sum[i][x]. The same as dp, we only need to use two array to record sum, sum[i][x] means dp[i][x] + dp[i][x - 1] + ..... + dp[i][x - k + 1]. When x is biger than k, sum[i][x] = sum[i][x - 1] - dp[i][x - 1 - k] + dp[i][x], otherwise sum[i][x] = sum[i][x - 1] + dp[i][x]; Just remember the defination of dp and sum, and you can easily understand the code below. Previously: dp[i][j] = x, means we can use x ways to get the sum of all dice’s face-up number to j with i dice. sum[i][j] = x, means the sum of dp[i][j], dp[i][j - 1], ......, dp[i][j - k + 1]. C++ Accepted Code(7ms(98%), 6MB(97%)) class Solution { public: int dp[2][1001]; int mod; int sum[2][1001]; int numRollsToTarget(int n, int k, int target) { mod = 1e9 + 7; dp[0][0] = 1; for(int i = 0; i \u003c k; ++i) sum[0][i] = 1; for(int i = 1; i \u003c= n; ++i){ for(int x = 1; x \u003c= target; ++x){ dp[(i \u0026 1)][x] = sum[!(i \u0026 1)][x - 1]; if(x \u003e= k) sum[i \u0026 1][x] = (sum[i \u0026 1][x - 1] - dp[i \u0026 1][x - k] + mod) % mod + dp[i \u0026 1][x]; else sum[i \u0026 1][x] = sum[i \u0026 1][x - 1] + dp[i \u0026 1][x]; sum[i \u0026 1][x] %= mod; dp[i \u0026 1][x] %= mod; } memset(dp[!(i \u0026 1)], 0, sizeof(dp[!(i \u0026 1)])); memset(sum[!(i \u0026 1)], 0, sizeof(sum[!(i \u0026 1)])); } return dp[n \u0026 1][target]; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:28:3","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-01 91. Decode Ways Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:29:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial If We could only format single digit to letter (except digit 0), the answer will be 1. So the only way to increse the answer is we combine two digits for decoding a letter. We traverse the string, define dp[i] means end with s[i - 1], we will get dp[i] ways to decode the string, for easy, we transfer dp[i] to dp[i + 1]. Like said above, if we just use one digit to decode, we won’t get new answer. So if s[i] is not ‘0’, dp[i + 1] is equal to dp[i]. If s[i] is ‘0’, dp[i + 1] is 0, because we cannot decode ‘0’ to any letter. Meanwhile, for every i (i \u003e 0), we could check whether s[i - 1, i] is an valid digit string to decode to a single letter, if so, we could let dp[i + 1] add dp[i - 1]. By this logic, evertime s[i - 1] and s[i +1] can be combined to decode a letter, the answer increase. C++ Accepted Code1:(4ms, 6.2MB) class Solution { public: int dp[105]; int numDecodings(string s) { memset(dp, 0, sizeof(dp)); dp[0] = 1; for(int i = 0; i \u003c s.size(); ++i){ if(s[i] != '0') dp[i + 1] = dp[i]; if(i \u003e 0 \u0026\u0026 (s[i - 1] == '1' || s[i - 1] == '2' \u0026\u0026 s[i] \u003c= '6')) dp[i + 1] += dp[i - 1]; printf(\"dp[%d] = %d\\n\", i, dp[i]); } return dp[s.size()]; } }; If you carefully look this code, you will find that, although we use dp to cal the answer, we only need to use dp[i], dp[i - 1], and dp[i + 1], which means we only need three avariables. So we can Smplify this code to the below one: C++ Accepted Code2:(0ms, 6MB) class Solution { public: int numDecodings(string s) { int fi = 0, se = 1; int cur = 0; for(int i = 0; i \u003c s.size(); ++i){ cur = 0; if(s[i] != '0') cur = se; if(i \u003e 0 \u0026\u0026 (s[i - 1] == '1' || s[i - 1] == '2' \u0026\u0026 s[i] \u003c= '6')) cur += fi; fi = se, se = cur; } return cur; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:29:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"D. Guess The String ","date":"2022-07-09","objectID":"/en/posts/cf/codeforces-1697-d-tutorial/:0:0","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/cf/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Problem summary The Jury chosen a stringS consisting of n characters; each character of S is a lowercase Latin letter. You may ask query in two types: 1 i - query for the letterSi 2 l r - query the size of character set of Sl,Sl+1,......,Sr You are allowed to ask no more than 26 queries of the first type, and no more than 6000 queries of the second type. Output the final S you found in ! S ","date":"2022-07-09","objectID":"/en/posts/cf/codeforces-1697-d-tutorial/:0:1","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/cf/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Sample Input 5 4 u 2 g e s 1 ","date":"2022-07-09","objectID":"/en/posts/cf/codeforces-1697-d-tutorial/:0:2","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/cf/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Sample Ouput ? 2 1 5 ? 1 2 ? 2 1 2 ? 1 1 ? 1 3 ? 1 4 ? 2 4 5 ! guess ","date":"2022-07-09","objectID":"/en/posts/cf/codeforces-1697-d-tutorial/:0:3","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/cf/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Tourial First, it is easy to recognize that first type of operate is to find the letters which are first time appear. so, the first question is when we construct string, how to know whether the character has ever appeared. We define f(x, y) represent the size of the charater-set in range [x, y]. We know that 2nd op tell us the size of the charater-set. So abviously we solve the question by perform 2nd op. If we construct the string in order, we query f(1, x) and f(1, x - 1), if f(1, x) bigger than f(1, x -1), means s[x] never appeared in s[1] - s[x - 1]. and then we perform 1st op to judge the character of s[x]. After that, the new question appeares: how to know the character X, if f(1, x) equals to f(1, x - 1). Assume we know every charater in s[1] to s[x - 1], and s[x] has appeared in this range. limited by the perform times of 2nd op. we can only perform 6 times max for s[x]. Because We construct the answer string in order, the monotonicity implict in problem is: from left to right, the longer the string, the monotoncically increasing the charater-set’s size. Base on it, we could use binary search to guess s[x]. We record every character’s last position. We already know f(lastPos[mid], x - 1), so if f(mid, x) equals to f(mid, x - 1), means s[x] last appeared in rangelastPos[s[mid]]to (x - 1). Through the binary search, we could find s[x] last appeared position, and easily to konw s[x]. ","date":"2022-07-09","objectID":"/en/posts/cf/codeforces-1697-d-tutorial/:0:4","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/cf/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Code //CPP void solveD(){ int n; scanf(\"%d\", \u0026n); char s[n + 5]; s[n + 1] = '\\0'; printf(\"? 1 1\\n\"); fflush(stdout); scanf(\" %c\", \u0026s[1]); PIC lastPos[26]; int tot = 1; lastPos[tot] = PIC(1, s[1]); for(int i = 2; i \u003c= n; ++i){ printf(\"? 2 1 %d\\n\", i); fflush(stdout); int sz; scanf(\" %d\", \u0026sz); if(sz != tot) { printf(\"? 1 %d\\n\", i); fflush(stdout); scanf(\" %c\", \u0026s[i]); lastPos[++tot] = PIC(i, s[i]); continue; } sort(lastPos + 1, lastPos + tot + 1); int l = 1, r = tot; int ans = 0; while(l \u003c= r){ int mid = l + r \u003e\u003e 1; printf(\"? 2 %d %d\\n\", lastPos[mid].first, i); fflush(stdout); scanf(\" %d\", \u0026sz); if(sz == tot - mid + 1) ans = mid, l = mid + 1; else r = mid - 1; } s[i] = lastPos[ans].second; lastPos[ans].first = i; } printf(\"! %s\\n\", s + 1); fflush(stdout); } ","date":"2022-07-09","objectID":"/en/posts/cf/codeforces-1697-d-tutorial/:0:5","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/cf/codeforces-1697-d-tutorial/"},{"categories":["leetcode hard"],"content":"my solution","date":"2022-05-28","objectID":"/en/posts/lc/hard/0004_median_of_two_sorted_arrays/","tags":["priority_queue"],"title":"4. Median of Two Sorted Arrays","uri":"/en/posts/lc/hard/0004_median_of_two_sorted_arrays/"},{"categories":["leetcode hard"],"content":"https://leetcode.com/problems/median-of-two-sorted-arrays/ https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/708741884/ class Solution { public: double findMedianSortedArrays(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) { priority_queue\u003cint\u003e q; for(int i : nums1) q.push(i); for(int i : nums2) q.push(i); int popCount = q.size() - 1 \u003e\u003e 1; bool d = (q.size() % 2 == 0); while(popCount--) q.pop(); double ans = 0; ans = q.top(); q.pop(); if(d){ ans = (q.top() + ans) / 2.0; } return ans; } }; ","date":"2022-05-28","objectID":"/en/posts/lc/hard/0004_median_of_two_sorted_arrays/:0:0","tags":["priority_queue"],"title":"4. Median of Two Sorted Arrays","uri":"/en/posts/lc/hard/0004_median_of_two_sorted_arrays/"}]