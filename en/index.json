[{"categories":null,"content":"Origin Link https://leetcode.com/problems/range-sum-query-mutable/ ","date":"2023-05-05","objectID":"/en/posts/leetcode-307-range-sum-query-mutable/:0:1","tags":null,"title":"LeetCode 307 Range Sum Query Mutable","uri":"/en/posts/leetcode-307-range-sum-query-mutable/"},{"categories":null,"content":"Tutorial easy data structure, using segment tree or binary indexed tree。 ","date":"2023-05-05","objectID":"/en/posts/leetcode-307-range-sum-query-mutable/:0:2","tags":null,"title":"LeetCode 307 Range Sum Query Mutable","uri":"/en/posts/leetcode-307-range-sum-query-mutable/"},{"categories":null,"content":"Ac Code class NumArray { public: NumArray(vector\u003cint\u003e\u0026 nums) { for(int i = 0; i \u003c nums.size(); ++i) n[i + 1] = nums[i]; l = nums.size(); build(1, l, 1); } void update(int index, int val) { updateNode(1, l, 1, index + 1, val); } int sumRange(int left, int right) { return sum(1, l, 1, left + 1, right + 1); } private: int n[30005]; int l; int node[30005 * 3]; void build(int l, int r, int k) { if(l == r){ node[k] = n[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, k \u003c\u003c 1); build(mid + 1, r, k \u003c\u003c 1 | 1); node[k] = node[k \u003c\u003c 1] + node[k \u003c\u003c 1 | 1]; } void updateNode(int l, int r, int k, int x, int val){ if(l == r){ node[k] = val; return; } int mid = (l + r) \u003e\u003e 1; if(mid \u003c x) updateNode(mid + 1, r, k \u003c\u003c 1 | 1, x, val); else updateNode(l, mid, k \u003c\u003c 1, x, val); node[k] = node[k \u003c\u003c 1] + node[k \u003c\u003c 1 | 1]; } int sum(int l, int r, int k, int L, int R){ if(L \u003c= l \u0026\u0026 R \u003e= r) return node[k]; int ans = 0; int mid = (l + r) \u003e\u003e 1; if(L \u003c= mid) ans += sum(l, mid, k \u003c\u003c 1, L, R); if(R \u003e mid) ans += sum(mid + 1, r, k \u003c\u003c 1 | 1, L, R); return ans; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-\u003eupdate(index,val); * int param_2 = obj-\u003esumRange(left,right); */ ","date":"2023-05-05","objectID":"/en/posts/leetcode-307-range-sum-query-mutable/:0:3","tags":null,"title":"LeetCode 307 Range Sum Query Mutable","uri":"/en/posts/leetcode-307-range-sum-query-mutable/"},{"categories":null,"content":"Q2 ","date":"2022-11-13","objectID":"/en/posts/leetcode-biweekly-contest-91-tutorial/:1:0","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Tutorial An easy dp problem, for dp[i], means how many good string of length i. Init dp[zero] = 1, dp[one] = 1 (if one == zero, then dp[one] = 2); So dp[i] = dp[i - zero] + dp[i - one]. After calculate all dp, sum up dp[low] to dp[high]. Accepted Code class Solution { public: long long dp[100005]; int countGoodStrings(int low, int high, int zero, int one) { memset(dp, 0, sizeof(dp)); dp[zero]++; dp[one]++; for(int i = min(zero, one); i \u003c= high; ++i){ if(i \u003e zero) dp[i] += dp[i - zero]; if(i \u003e one) dp[i] += dp[i - one]; dp[i] %= 1000000007; } long long ans = 0; for(int i = low; i \u003c= high; ++i){ ans += dp[i]; ans %= 1000000007; } return ans; } }; ","date":"2022-11-13","objectID":"/en/posts/leetcode-biweekly-contest-91-tutorial/:1:1","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Q3 ","date":"2022-11-13","objectID":"/en/posts/leetcode-biweekly-contest-91-tutorial/:2:0","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Tutorial First, from root 0, bfs all tree to find where bob is. Storage the parent node of every node. Secondly, from Bob Node, Stroage the time that bob will visit from bob node to root. Last, from node 0, calculate alice’s maximum income to all leaf. Accepted Code class Solution { public: int bobVisTime[100005]; vector\u003cint\u003e to[100005]; int dp[100005]; map\u003cint, int\u003e par; int res; int mostProfitablePath(vector\u003cvector\u003cint\u003e\u003e\u0026 edges, int bob, vector\u003cint\u003e\u0026 amount) { memset(bobVisTime, 0x3f3f3f3f, sizeof(bobVisTime)); memset(dp, 0, sizeof(dp)); res = INT_MIN; for(auto i : edges){ int a = i[0], b = i[1]; to[a].push_back(b); to[b].push_back(a); } fillBobVisTime(bob); dfs(0, 0, -1, 0, amount); return res; } void dfs(int a, int t, int p, int ans, const vector\u003cint\u003e \u0026amount){ //printf(\"a = %d, t = %d, ans = %d, bobVisTime = %d\\n\", a, t, ans, bobVisTime[a]); if(t == bobVisTime[a]){ //同时到达 ans += amount[a] / 2; } else if(bobVisTime[a] \u003e t){ //alice先到 ans += amount[a]; } else{ // bob先到 ans += 0; } for(int i : to[a]){ if(i != p) dfs(i, t + 1, a, ans, amount); } if(to[a].size() == 1 \u0026\u0026 a != 0){ //leaf //printf(\"a = %d\\n\", a); res = max(res, ans); } return; } void fillBobVisTime(int b){ queue\u003cpair\u003cint, int\u003e\u003e q; q.push({0, 0}); while(!q.empty()){ pair\u003cint, int\u003e t = q.front(); q.pop(); for(int i : to[t.first]){ if(bobVisTime[i] != 0x3f3f3f3f) continue; bobVisTime[i] = t.second + 1; par[i] = t.first; q.push({i, t.second + 1}); } } memset(bobVisTime, 0x3f3f3f3f, sizeof(bobVisTime)); int cnt = 0; while(b != 0){ bobVisTime[b] = cnt++; b = par[b]; } bobVisTime[0] = cnt; return; } }; ","date":"2022-11-13","objectID":"/en/posts/leetcode-biweekly-contest-91-tutorial/:2:1","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Q4 ","date":"2022-11-13","objectID":"/en/posts/leetcode-biweekly-contest-91-tutorial/:3:0","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"Tutorial We define an array sumL of length 1e4. sumL[11] mean the length of all string: “1”, “2”, “3”, …… , “10”, “11”. So if there is an valid answer, we conbine all the splited string into one string, the length of the string is: message.length + sumL[b] + b * string_of_b.length + b * 3. If we don’t ignore the last part, make all part’s length equal to limit. The check will be very easy: limit * b == message.length + sumL[b] + b * string_of_b.length + b * 3. If we could find some b(from 1 to 1e4) satisfied this equation, make it to be the answer. But now, we can except the last part of message, whose length can be at most limit. So we just change the equation to be an inequality: limit * b - message.length + sumL[b] + b * string_of_b.length + b * 3 \u003c limit. If we could find a b satisfied this inequality, we find the answer. Accepted Code class Solution { public: int sumL[10005]; vector\u003cstring\u003e splitMessage(string message, int limit) { memset(sumL, 0, sizeof(sumL)); for(int i = 1; i \u003c= 10000; ++i){ sumL[i] = sumL[i - 1] + tos(i).size(); } for(int i = 1; i \u003c= 10000; ++i){ if(check(i, limit, message.size())){ return del(i, message, limit); } } return {}; } inline vector\u003cstring\u003e del(int b, string message, int limit){ vector\u003cstring\u003e res; int idx = 0; string bs = tos(b); int blen = bs.size(); for(int i = 1; i \u003c= b; ++i){ string tres = \"\"; string as = tos(i); int les = limit - 3 - blen - as.size(); tres = message.substr(idx, les) + \"\u003c\" + as + \"/\" + bs + \"\u003e\"; idx += les; res.push_back(tres); } return res; } inline bool check(int b, int limit, int mL){ if(limit * b - (mL + b * 3 + b * tos(b).size() + sumL[b]) \u003c limit){ return true; } return false; } inline string tos(int n){ string res = \"\"; while(n){ res += char(n % 10 + '0'); n /= 10; } reverse(res.begin(), res.end()); return res; } }; ","date":"2022-11-13","objectID":"/en/posts/leetcode-biweekly-contest-91-tutorial/:3:1","tags":null,"title":"LeetCode Biweekly Contest 91 Tutorial","uri":"/en/posts/leetcode-biweekly-contest-91-tutorial/"},{"categories":null,"content":"If you get any problem of my code or you find something wrong, just leave a comment or contact with me, I’ll response you as fast as I can if I see it. If this tutorial helps you well, you can subscribe my website, every time I update any Tutorial, I’ll send an email to all subscribers. ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:0:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-31 766. Toeplitz Matrix Difficulty: Easy Accepted Code class Solution { public: bool isToeplitzMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { vector\u003cint\u003e n[int(matrix.size() + matrix[0].size() - 1)]; int beginIdx = 0; for(int i = matrix.size() - 1; i \u003e= 0; --i){ int j = beginIdx; for(int k : matrix[i]) n[j++].push_back(k); beginIdx++; } for(auto i : n) { int j = i[0]; for(int k : i) if(k != j) return false; } return true; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:1:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-30 1293. Shortest Path in a Grid with Obstacles Elimination Difficulty: Hard ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:2:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial BFS Accepted Code( T/ M : 68.41%/82.45%) class Solution { public: int shortestPath(vector\u003cvector\u003cint\u003e\u003e\u0026 grid, int k) { int n = grid.size(), m = grid[0].size(); //define n, m as problem describe if(n == 1 \u0026\u0026 m == 1) return 0; queue\u003cpair\u003cpair\u003cint, int\u003e, pair\u003cint, int\u003e\u003e\u003e q; //( (x, y), (k, step) ) //current position(x, y), can elemate k obstacle, have moved step times; q.push({{0,0}, {k, 0}}); //start point int dx[] = {-1, 0, 1, 0}; //direction int dy[] = {0, -1, 0, 1}; //direction map\u003cpair\u003cint, int\u003e, int\u003e visit; for(int i = 0; i \u003c n; ++i) for(int j = 0; j \u003c m; ++j) visit[{i,j}] = -1; while(!q.empty()){ auto t = q.front(); q.pop(); for(int i = 0; i \u003c 4; ++i){ //traverse four directions int nx = t.first.first + dx[i]; //next x int ny = t.first.second + dy[i]; //next y int nk = t.second.first; //next k; //check is (nx, ny) end point; if(nx == n - 1 \u0026\u0026 ny == m - 1) return t.second.second + 1; // reach end point //check next position whether is valid or not if(nx \u003c 0 || nx \u003e= n || ny \u003c 0 || ny \u003e= m) continue; //out of grid; if(grid[nx][ny] == 1 \u0026\u0026 t.second.first == 0) continue; //next step is obstacle, but cannot elemate any obstacle now; if(grid[nx][ny]) nk--; if(visit[{nx, ny}] != -1 \u0026\u0026 visit[{nx, ny}] \u003e= nk) continue; visit[{nx, ny}] = nk; //move; q.push({{nx, ny}, {nk, t.second.second + 1}}); } } return -1; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:2:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-29 2136. Earliest Possible Day of Full Bloom Difficulty: Hard ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:3:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Obviously we need sum of plantTime to plant all the flowers. And After plant, we just need to wait all flowers grown-up. Look at the example 1, after we plant all flower, we need to wait third flower to grow. So plant the min grow time flower last could be better. So we sort all the flower by grow time in decreasing order. But there are some special cases. If we change example 1 to: plantTime = [4, 3], growTime = [6, 1]. the answer will be 4 + 6. First we use 4 days to plant 1st flower, and then we take 3 days to plant 2nd flower, and 2nd flower takes 1 days to grow. But 1st flower need 6 days to grow, while 1st flower is growing, we can plant 2nd flower and wait it grwon-up. So the answer only depends on the 1st flower. Accepted Code class Solution { public: int earliestFullBloom(vector\u003cint\u003e\u0026 plantTime, vector\u003cint\u003e\u0026 growTime) { int all = 0, ans = 0; int n = plantTime.size(); vector\u003cpair\u003cint, int\u003e\u003e pg; for(int i = 0; i \u003c n; ++i) pg.push_back({plantTime[i], growTime[i]}); sort(pg.begin(), pg.end(), [](pair\u003cint, int\u003e a, pair\u003cint, int\u003e b){ return a.second \u003e b.second; }); for(pair\u003cint, int\u003e it : pg){ all += it.first; ans = max(ans, all + it.second); // in case the special case, record the longest time to grow current flower. } return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:3:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-28 49. Group Anagrams Difficulty: Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:4:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial If two strings are in the same group, after sorting two strings, they will be the same string. It is easy to understand, because two strings have the same letter, and times of each letters’ appera are the same also. So just traverse all the string, use unordered_map or map to record the same string after sorting. Accepted Code:(T / M : 86.78% / 56.57%) class Solution { public: vector\u003cvector\u003cstring\u003e\u003e groupAnagrams(vector\u003cstring\u003e\u0026 strs) { unordered_map\u003cstring, vector\u003cstring\u003e\u003e pos; int cnt = 0; for(string s: strs){ sort(s.begin(), s.end()); pos[s].push_back(strs[cnt++]); } vector\u003cvector\u003cstring\u003e\u003eans; for(auto it : pos) ans.push_back(it.second); return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:4:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-27 835. Image Overlap Difficulty: Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:5:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial For the answer, we move ans step for every 1 in image1. For every 1 in image1, we make enumerate the last position in image2, make two 1 overlap, check the step, most step will be the ans. Because if we move ans steps, most 1 will overlap. Accepted Code: class Solution { public: int largestOverlap(vector\u003cvector\u003cint\u003e\u003e\u0026 img1, vector\u003cvector\u003cint\u003e\u003e\u0026 img2) { int n = img1.size(); vector\u003cpair\u003cint, int\u003e \u003e vp1, vp2; for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c n; j++){ if(img1[i][j]) vp1.push_back({i,j}); if(img2[i][j]) vp2.push_back({i,j}); } } int ans = 0; map\u003cpair\u003cint, int\u003e, int\u003e mp; for(auto it1 : vp1){ for(auto it2 : vp2){ int a = it1.first - it2.first; int b = it1.second - it2.second; mp[{a, b}]++; ans = max(ans, mp[{a, b}]); } } return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:5:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-26 523. Continuous Subarray Sum Difficulty: Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:6:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial If sum[1 ~ l] % k == 0 \u0026\u0026 sum[1 ~ r] % k == 0, sum[l ~ r] % k == 0, this judgement is valid when r - l \u003e 1. Accepted Code class Solution { public: bool checkSubarraySum(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e mp; int sum = 0; for(int i = 0; i \u003c nums.size(); ++i){ sum += nums[i]; sum %= k; if(mp.count(sum) != 0 \u0026\u0026 i - mp[sum] \u003e 1 || sum == 0 \u0026\u0026 i \u003e 0) return true; else if(mp.count(sum) == 0) mp[sum] = i; } return false; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:6:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-24 1239. Maximum Length of a Concatenated String with Unique Characters Difficulty: Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:7:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Use Dfs to enumerate all concatenated string, check whether is valid. Accepted Code: (T/M : 78.69% / 79.31%) class Solution { public: int maxLength(vector\u003cstring\u003e\u0026 arr) { return dfs(0, arr, \"\"); } int dfs(int idx, vector\u003cstring\u003e \u0026arr, string cur){ if(idx == arr.size()){ return cur.size(); } int ans = 0; for(int i = idx; i \u003c arr.size(); ++i){ string nxt = cur + arr[i]; if(check(nxt)){ ans = max(ans, int(nxt.size())); ans = max(ans, dfs(i + 1, arr, nxt)); } } return ans; } bool check(string s){ if(s.size() \u003e 26) return false; bool vis[26] = {false}; for(char i : s){ if(vis[i - 'a']) return false; vis[i - 'a'] = true; } return true; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:7:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-23 645. Set Mismatch Difficulty: Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:8:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial No Tutorial. Accepted Code class Solution { public: vector\u003cint\u003e findErrorNums(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); bool vis[10005]; memset(vis, false, sizeof(vis)); vector\u003cint\u003e res; for(int i : nums){ if(vis[i]) res.push_back(i); vis[i] = true; } for(int i = 1; i \u003c= n; ++i){ if(vis[i] == false){ res.push_back(i); return res; } } } }; more beautiful code from HERE vector\u003cint\u003e findErrorNums(vector\u003cint\u003e\u0026 nums) { for(int i = 0; i\u003cnums.size(); i++){ while(nums[i] != nums[nums[i] - 1])swap(nums[i], nums[nums[i] - 1]); } for(int i = 0; i\u003cnums.size() ; i++){ if(nums[i] != i + 1)return {nums[i], i + 1}; } } ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:8:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-22 76. Minimum Window Substring Difficulty: Hard ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:9:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Use two pointer。 I’m playing mahjong, I’ll write later First, use two pointer to index a window, which include all the letters in t. Second, try to make the window shorter by moving its left side. When shorting the window, make window always be valid. After second step, compare valid window length with current answer. If shorter, update answer. Third, continue to move window’s right side, util window include all letters in t, then repeat from second step. Accepted Code（T/M：80.58%， 94.27%） class Solution { public: string minWindow(string s, string t) { if(s.size() \u003c t.size()) return \"\"; int cnt[130] = {0}; bool exist[130] = {false}; for(char c: t) cnt[c]++, exist[c] = true; int minl = -1, minr = 1000000; int l = 0, r = 0, tn = t.size(); while(r \u003c s.size()){ if(exist[s[r]]){ if(--cnt[s[r]] \u003e= 0) tn--; if(tn == 0){ // current [l, r] include all letters in t. while(tn == 0){ //step 2nd. while(l \u003c= r \u0026\u0026 !exist[s[l]]) ++l; //move left side of the window. if(++cnt[s[l]] \u003e 0) ++tn; //if after move, window invalid, break current loop. ++l; } if(minr - minl \u003e r - l) minr = r, minl = l - 1; // compare with answer } } ++r; // step 3rd. } if(minl == -1) return \"\"; s = s.substr(minl, minr - minl + 1); return s; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:9:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-21 219. Contains Duplicate II Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:10:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Traverse nums, record all number last index in traversal, compare distance of current number index and last index with k, if valid, return true, else update last index to current index. Accepted Code class Solution { public: bool containsNearbyDuplicate(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e lastPos; for(int i = 0; i \u003c nums.size(); ++i){ if(lastPos[nums[i]] == 0) lastPos[nums[i]] = i + 1; else{ if(i + 1 - lastPos[nums[i]] \u003c= k) return true; lastPos[nums[i]] = i + 1; } } return false; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:10:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-19 692. Top K Frequent Words Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:11:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Count the number of occurrences of every word. Make word and its count be an struct, sort the struct list, and select top k frequent words. Accepted Code (T/M : 27.39%/39.56%) class Solution { public: unordered_map\u003cstring, int\u003e count; struct Word{ string w; int count; friend bool operator \u003c (Word a, Word b){ if(a.count != b.count) return a.count \u003e b.count; return a.w \u003c b.w; } }; vector\u003cstring\u003e topKFrequent(vector\u003cstring\u003e\u0026 words, int k) { for(string s : words) count[s]++; vector\u003cWord\u003e s; for(auto it: count){ s.push_back((Word){it.first, it.second}); } sort(s.begin(), s.end()); vector\u003cstring\u003e res; for(int i = 0; i \u003c k; ++i) res.push_back(s[i].w); return res; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:11:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-18 38. Count and Say Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:12:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial For countAndSay(n), calculate countAndSay(n - 1) til n == 1 by DFS. Accepted Code(T/M : 66%/89.76%) class Solution { public: string countAndSay(int n) { if(n == 1) return \"1\"; string pre = countAndSay(n - 1); int cnt = 1; string cur = \"\"; for(int i = 0; i \u003c pre.size() - 1; ++i){ if(pre[i] == pre[i + 1]){ cnt++; } else{ cur += getNum(cnt); cur += pre[i]; cnt = 1; } } cur += getNum(cnt); cur += pre[pre.size() - 1]; return cur; } string getNum(int n){ string res = \"\"; while(n){ res += char(n % 10 + '0'); n /= 10; } reverse(res.begin(), res.end()); return res; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:12:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-17 1832. Check if the Sentence Is Pangram Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:13:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Accepted Code（T/M ：80.43%/100%） class Solution { public: bool checkIfPangram(string sentence) { int cnt = 0; for(char c : sentence) cnt |= (1 \u003c\u003c (c - 'a')); return cnt == 67108863; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:13:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-16 1335. Minimum Difficulty of a Job Schedule ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:14:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial It a very classic dp problem: split an array to dsubarrarys, minimize the sum of all subarray’s maximum number. Usually, we use two-dimensional array dp to solve this kind of problem. dp[idx][d], idx represents current index, d represents we need to split the remaining arrary [idx, n] to d subarrarys. Enumerate the endpoints of first subarrary from idx to n, calculate best dp[endPoint + 1][d - 1]. With dfs, the last state we need to calculate is: get one subarray, make the max number minimum(dp[x][1]). When dfs returns, we could get dp[x - 1][2]. At last, we get dp[0][d], which is our answer. To be clear: dp[idx][d] = min(dp[idx + 1][d - 1], dp[idx + 2][d - 1], dp[idx +3][d - 1], …… , dp[n][d - 1]). So we set invalid dp state to infinite to avoid affecting dp[idx][d]. Accepted Code(T/M : 88.85%/99.15%) class Solution { public: int dp[305][15]; int dfs(int idx, int d, const vector\u003cint\u003e \u0026job){ if(dp[idx][d] != -1) return dp[idx][d]; // have been calculated. if(idx == job.size() \u0026\u0026 d == 0) return 0; // dp[n][0] = 0 if(idx == job.size() || d == 0) return 0x3f3f3f3f; //invalid, d is not 0, but job is splited over or remain d days to split, but no job. if(job.size() - idx \u003c d) return 0x3f3f3f3f; //invalid, cannot split job[idx :] to d subarrays. int m = job[idx], ans = 0x3f3f3f3f; for(int i = idx; i \u003c job.size(); ++i){ m = max(m, job[i]); ans = min(ans, m + dfs(i + 1, d - 1, job)); // dp[idx][d] = maxJobDiff(idx, i) + dp[i + 1][d - 1]; } dp[idx][d] = ans; return ans; } int minDifficulty(vector\u003cint\u003e\u0026 job, int d) { memset(dp, -1, sizeof(dp)); if(job.size() \u003c d) return -1; return dfs(0, d, job); } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:14:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-15 1531. String Compression II ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:15:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial https://leetcode.com/problems/string-compression-ii/discuss/756022/C%2B%2B-Top-Down-DP-with-explanation-64ms-short-and-clear Accepted Code class Solution { public: int dp[101][101]; int N; int getCodingLen(int l){ if(l == 1) return 1; if(l \u003c= 9) return 2; if(l \u003c= 99) return 3; return 4; } int dfs(const string \u0026s, int idx, int k){ if(k \u003c 0) return N; //cannot delete any letter, return max len; if(dp[idx][k] != -1) return dp[idx][k]; //have been calculated; if(idx \u003e= N or N - idx \u003c= k) return 0; //delete all remain letters; dp[idx][k] = N; //initiate dp int maxCnt = 0; //declear maxCnt int cnt[26] = {0}; //declear cnt to record each letters count in s[idx] -\u003e s[i]; for(int i = idx; i \u003c N; ++i){ maxCnt = max(maxCnt, ++cnt[s[i] - 'a']); //calculate maxCnt dp[idx][k] = min(dp[idx][k], getCodingLen(maxCnt) + dfs(s, i + 1, k - (i - idx + 1 - maxCnt))); //after delete all letters(most commonly apperaed in s[idx]-\u003es[i]) } return dp[idx][k]; } int getLengthOfOptimalCompression(string s, int k) { N = s.size(); memset(dp, -1, sizeof(dp)); return dfs(s, 0, k); } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:15:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-14 2095. Delete the Middle Node of a Linked List Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:16:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial This type of problem’s most commonly solution is use two pointer, one is move faster than the other. As for this problem, we need to move faster pointer 2 node per time, slower pointer move one by one. Only if the faster pointer could not move anymore, we stop the movement. At that time, the slower pointer is pointing to the previous node of middle node. And then change the next node of current node to be the next next node, the problem solved. Accepted Code (T/M : 99.38%/64.88%) class Solution { public: ListNode* deleteMiddle(ListNode* head) { ListNode *h = head; if(head -\u003e next == nullptr) return nullptr; ListNode *fast = head -\u003e next; while(fast != nullptr \u0026\u0026 fast -\u003e next != nullptr \u0026\u0026 fast -\u003e next -\u003e next != nullptr) { head = head -\u003e next; fast = fast -\u003e next -\u003e next; } head -\u003e next = head -\u003e next -\u003e next; return h; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:16:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-13 237. Delete Node in a Linked List Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:17:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial If We know the head node, we could traverse the linked list, if node-\u003enext-\u003eval == targetValue, then node-\u003enext = node-\u003enext-\u003enext. But now we only know the targetNode we need to remove, so we could’n change the next pointer to remove given node. Cause answer check only check the value in the link list. We can move all the value after give node forward one node, and then, delete the last node. process: 4 -\u003e 5 -\u003e 1 -\u003e 9 4 -\u003e 1 -\u003e 1 -\u003e 9 4 -\u003e 1 -\u003e 9 -\u003e 9 4 -\u003e 1 -\u003e 9 Accepted Code(T/M: 44%/92%) class Solution { public: void deleteNode(ListNode* node) { while(node -\u003e next -\u003e next != nullptr) { node -\u003e val = node -\u003e next -\u003e val; node = node -\u003e next; } node -\u003e val = node -\u003e next -\u003e val; node -\u003e next = nullptr; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:17:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-12 976. Largest Perimeter Triangle Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:18:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial For a triangle, any two vertices’ sum should bigger than remain one. So we sort all the numbers, and from big to small, check the smaller two numbers’ sum whether bigger than the biggest one. If so, this three number can form a triangle. Accepted Code class Solution { public: int largestPerimeter(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); for(int i = nums.size() - 1; i - 2 \u003e= 0; --i){ if(nums[i - 2] + nums[i - 1] \u003c= nums[i]) continue; return nums[i - 2] + nums[i - 1] + nums[i]; } return 0; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:18:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-11 334. Increasing Triplet Subsequence Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:19:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Consider a very easy problem: Give you an array, find two element a and b, required a \u003c b, if exist valid a and b, return true. else return false. To solve this question, we only need one variable a, if current element i smaller than a, assign i to a, else if i bigger than a, return true, after traverse the array, return false. Back to this problem, before we return true(find valid a and b), we need another element c, c is smaller than a. if we could find valid c, the problem will be solved. Now, If we find a valid c before find a and b, remain problem is exactly the same as the easy problem above. The different is, before we update a to be an smaller number, we need to be sure that new a is bigger than c. Accepted Code class Solution { public: bool increasingTriplet(vector\u003cint\u003e\u0026 nums) { if(nums.size() \u003c 3) return false; int c = INT_MAX, a = INT_MAX; for(int i = 0; i \u003c nums.size(); ++i){ if(nums[i] \u003c= c) c = nums[i]; //update c first else if(nums[i] \u003c= a) a = nums[i]; //if nums[i] is bigger than c, but smaller than a, we could update a to nums[i], every time we update a to be a smaller number, the range of valid b is bigger. else return true; } return false; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:19:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-10 1328. Break a Palindrome Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:20:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial First of all, if palindrome’s length is 1, we could not make it not palindromic. Secondly, If palindrome’s length is odd, we could not make it not palindromic by change the letter in the middle. Otherwise, If we change any letter, the palindrome will not palindromic anymore. For purpose, we need to break the palindrome and at the same time make it lexicographically smallest, we only need to change a valid letter(can change the palindromic) to be ‘a’, if we could’n find a valid letter, change the last letter to be ‘b’. Because at that time, all the valid letter is ‘a’, so the last letter must be ‘a’ also. Accepted Code(100%, 45%) class Solution { public: string breakPalindrome(string palindrome) { if(palindrome.size() == 1) return \"\"; bool isEven = !(palindrome.size() % 2); for(int i = 0; i \u003c palindrome.size(); ++i){ if(palindrome[i] != 'a'){ if(!isEven \u0026\u0026 palindrome.size() / 2 == i) continue; palindrome[i] = 'a'; return palindrome; } } palindrome[palindrome.size() - 1] = 'b'; return palindrome; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:20:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-09 653. Two Sum IV - Input is a BST Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:21:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial DFS this BST, and while searching, check whether exist value equal to target - currentRoot-\u003eval. Accepted Code(92.29% / 98.68%) class Solution { public: bool exist[30001]; bool findTarget(TreeNode* root, int k) { if(root == nullptr) return false; if(exist[k - root-\u003eval + 10000] == true) return true; exist[root-\u003eval + 10000] = true; return findTarget(root -\u003e left, k) || findTarget(root-\u003eright, k); } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:21:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-08 16. 3Sum Closest Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:22:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial As we could see, if we use brute force to solve the problem, it need O(n3) time complexity, which is unacceptable. So at least, we need to improve time complexity to O(n2). We consider another easier problem first: give a sorted array, find two numbers in array, which’s sum is closest to target. Because this array is sorted, if we use two pointers, l and r, l = 1, r = array.size(). For every time we move pointer, we could easily know: if move l to l + 1, will make current sum bigger, if move r to r - 1, will make current sum smaller. So if current sum is smaller than target, we should move l to l + 1 to make it bigger, vice versa. And after every time moving, we could check whether current sum is the closet sum to target. This approach’s time complexity is O(n). Back to the origin problem. We only need to enumerate first number, and then the problem we need to solve is just exactly the same with the problem above. All time complexity is O(nlogn + n2). Accepted Code class Solution { public: int threeSumClosest(vector\u003cint\u003e\u0026 nums, int target) { sort(nums.begin(), nums.end()); int ans = nums[0] + nums[1] + nums[2]; int n = nums.size(); for(int i = 0; i \u003c n - 2; ++i){ int l = i + 1, r = n - 1; int tans = nums[i] + nums[l] + nums[r]; while(l \u003c r) { if(check(tans, ans, target, \u0026ans)) ; if(check(tans - nums[r] + nums[r - 1], tans - nums[l] + nums[l + 1], target, \u0026tans)) r--; else l++; } } return ans; } bool check(int n1, int n2, int target, int *ans) { //return true if n1 is closer than n2 to target. if(abs(n1 - target) \u003c abs(n2 - target)) { *ans = n1; return true; } *ans = n2; return false; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:22:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-07 732. My Calendar III ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:23:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial For every event, the range where it contribute to the answer, is [event, end - 1]. So we only need to record all event point, and then traverse all point, calculate current k event. Accepted Code(6%/100%) class MyCalendarThree { public: MyCalendarThree() { } int book(int start, int end) { add(start, end); return check(); } private: vector\u003cint\u003e ev; inline void add(int s, int e){ //be invoked n times; ev.push_back(s); ev.push_back(-e); sort(ev.begin(), ev.end(), [](int a, int b){ //O(nlogn); if(abs(a) == abs(b)) return a \u003c b; // to prevent after sorted, will turn up like: 50, -50 return abs(a) \u003c abs(b); }); return; } inline int check(){ int res = 0, cur = 0; for(int i = 0; i \u003c ev.size(); ++i){ cur += ev[i] \u003c 0 ? -1 : 1; res = max(res, cur); } return res; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:23:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-06 981. Time Based Key-Value Store Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:24:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Read the code Accepted Code class TimeMap { public: TimeMap() { } void set(string key, string value, int timestamp) { mapKey2Time[key].insert(timestamp); kv[key][timestamp] = value; } string get(string key, int timestamp) { auto it = mapKey2Time[key].upper_bound(timestamp); if(it == mapKey2Time[key].begin()) return \"\"; it--; return kv[key][*it]; } private: unordered_map\u003cstring, ::set\u003cint\u003e \u003e mapKey2Time; unordered_map\u003cstring, unordered_map\u003cint, string\u003e\u003e kv; }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:24:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-05 623. Add One Row to Tree Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:25:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Observed this two examles, we could find that, add row in depth is to add two new TreeNode to all node which’s depth is depth - 1. And then, the right new node inherit father’s left subtree, right new node inherit father’s right subtree. So We could Use DFS or BFS to find the target node, which’s depth is depth - 1. Accepted Code With DFS(9.9%/98.26%) class Solution { public: TreeNode* addOneRow(TreeNode* root, int val, int depth) { if(depth == 1) { TreeNode *nRoot = new(TreeNode); nRoot-\u003eval = val; nRoot-\u003eleft = root; return nRoot; } addRow(root, 1, val, depth); return root; } private: void addRow(TreeNode* root, int currentDepth, int val, int depth){ if(root == nullptr) return; if(currentDepth + 1 == depth) { TreeNode *left = new(TreeNode); left-\u003eleft = root-\u003eleft; left-\u003eval = val; TreeNode *right = new(TreeNode); right-\u003eright = root-\u003eright; right-\u003eval = val; root-\u003eleft = left, root-\u003eright = right; return; } addRow(root-\u003eleft, currentDepth+1, val, depth); addRow(root-\u003eright, currentDepth+1, val, depth); return; } }; Accepted Code With BFS(85.7%/16.59%) class Solution { public: TreeNode* addOneRow(TreeNode* root, int val, int depth) { if(depth == 1) { TreeNode *nRoot = new(TreeNode); nRoot-\u003eval = val; nRoot-\u003eleft = root; return nRoot; } NewNode *nroot = new(NewNode); nroot-\u003enode = root; nroot-\u003edep = 1; vector\u003cTreeNode*\u003e targetNode; //all the target depth TreeNode queue\u003cNewNode\u003e q; q.push(*nroot); while(!q.empty()){ NewNode f = q.front(); q.pop(); if(f.dep + 1 == depth) { targetNode.push_back(f.node); } else{ if(f.node-\u003eleft != nullptr){ q.push((NewNode){f.node-\u003eleft, f.dep+1}); } if(f.node-\u003eright != nullptr){ q.push((NewNode){f.node-\u003eright, f.dep+1}); } } } for(int i = 0; i \u003c targetNode.size(); ++i){ TreeNode *r = targetNode[i]; TreeNode *left = new(TreeNode), *right = new(TreeNode); left-\u003eval = right-\u003eval = val; left-\u003eleft = r-\u003eleft; right-\u003eright = r-\u003eright; r-\u003eright = right; r-\u003eleft = left; } return root; } private: struct NewNode{ TreeNode *node; int dep; }; }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:25:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-04 112. Path Sum Difficulty：Easy ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:26:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Nothing to say, read the code. Accepted Code (13ms, 21.6MB) class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { return solve(root, targetSum, 0); } bool solve(TreeNode *root, int t, int c) { if(root == nullptr) return false; if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr) return t == (c + root-\u003eval); return solve(root-\u003eleft, t, c + root-\u003eval) || solve(root-\u003eright, t, c + root-\u003eval); } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:26:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-03 1578. Minimum Time to Make Rope Colorful Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:27:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Obviously, when some balloons have the same color and they are adjcent to each other, we need to remove all the ballon except the neededTime is minimum. So for easily, we can use prioriy_queue to restore all the neededTime of adjcent ballons, and remove the minimum neededTime, then sum the remain neededTime. Accepted Code 1(638 ms(5%), 106.6 MB(5%)) class Solution { public: int minCost(string colors, vector\u003cint\u003e\u0026 neededTime) { int n = colors.size(); int sum = 0; for(int i = 0; i \u003c n - 1; ++i){ if(colors[i] == colors[i + 1]){ priority_queue\u003cint\u003e q; while(i \u003c n - 1 \u0026\u0026 colors[i] == colors[i + 1]) q.push(neededTime[i++]); q.push(neededTime[i]); q.pop(); while(!q.empty()) { sum += q.top(); q.pop(); } } } return sum; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:27:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"First step improvement In fact, we only need to know two variables, the adjcent ballons summation of neededTime and the maximum neededTime. So we don’t really need to use priority_queeu to do that. just calculate this two variables by ourself. First Step Improvement Accepted Code(159 ms(95%), 95.4MB(84%)) class Solution { public: int minCost(string colors, vector\u003cint\u003e\u0026 neededTime) { int ans = 0; int l = 0, r = 1; int sum = 0, maxT = 0; int n = colors.size(); if(n == 1) return 0; while(r \u003c n){ maxT = neededTime[l]; sum = maxT; while(colors[l] == colors[r]){ maxT = max(maxT, neededTime[r]); sum += neededTime[r]; r++; } if(r - l == 1){ //eg: abc, l = 0, r = 1, don't need to remove any ballon. ++l; ++r; //move to next ballon; } else { //eg: aabaa, [-1,2,3,4,1]; l = 0, r = 2, sum = 1 + 2 = 3, maxT = 2, need to remove 1 ballon. ans += sum - maxT; l = r++; } } return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:27:2","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Second step improvement This step is not to improve the efficiency of the code. Just improve the code beauty. We can learn from the idea of bubble-sorting, make the maximum neededTime to the last position, and in process, we sum the other neededTime. Second step Accepted Code(156 ms(96%), 95.5 MB(50%)) class Solution { public: int minCost(string colors, vector\u003cint\u003e\u0026 neededTime) { int ans = 0; int n = colors.size(); for (int i = 0; i + 1 \u003c colors.size(); i++) { if (colors[i] == colors[i + 1]) { if (neededTime[i] \u003e neededTime[i + 1]) { ans += neededTime[i + 1]; //add smaller time neededTime[i + 1] = neededTime[i]; //bubble; } else ans += neededTime[i]; } } return ans; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:27:3","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-02 1155. Number of Dice Rolls With Target Sum Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:28:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial Obviously we need to us dp to solve this problem. Define a two-dimensional array dp, dp[i][j] means, the count of ways that if we use i dice to get sum j. So the transfer equation of dp[i][j] is: the sum of the dp[i - 1][j - k], k means ith dice’s number. The equation’s meaning is if we use i dice, and we have know all count of ways that if we use i-1 dice to get targets, current dice face-up number is k, so the dp[i][j] must be dp[i - 1][j - k]’s sum. C++ Accepted Code(43ms, 6MB) class Solution { public: int dp[31][1001]; // dp[i][j] = x, used i dices, get sum j, have x ways; int mod; int numRollsToTarget(int n, int k, int target) { mod = 1e9 + 7; dp[0][0] = 1; for(int i = 1; i \u003c= n; ++i){ for(int x = 1; x \u003c= target; ++x){ for(int j = 1; j \u003c= k; ++j){ if(j \u003e x) break; //invalid; dp[i][x] += dp[i - 1][x - j]; dp[i][x] %= mod; } } } return dp[n][target]; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:28:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Improve1: As we can see, In above code, we only use dp[i] and dp[i - 1], this 2 array, so we can optimize other space, only use dp[2][target]. Detail to see code below. C++ Accepted Code(51ms, 5.9MB(99%)) class Solution { public: int dp[2][1001]; int mod; int numRollsToTarget(int n, int k, int target) { mod = 1e9 + 7; dp[0][0] = 1; for(int i = 1; i \u003c= n; ++i){ for(int x = 1; x \u003c= target; ++x){ for(int j = 1; j \u003c= k; ++j){ if(j \u003e x) break; //invalid; dp[i \u0026 1][x] += dp[!(i \u0026 1)][x - j]; dp[i \u0026 1][x] %= mod; } } memset(dp[!(i \u0026 1)], 0, sizeof(dp[!(i \u0026 1)])); } return dp[n \u0026 1][target]; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:28:2","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Improve2: In the third loop, we calculate dp[i \u0026 1][x] asdp[i \u0026 1][x] += dp[!(i\u00261)][x - j], is very similar to another thing: the prefix sum. If we record the dp[i][x - 1] + dp[i][x - 2] + ...... + dp[i][x - k] as sum[i][x - 1], we could calculate dp[i + 1][x] which is the sum of dp[i][x- 1], dp[i][x - 2], ......, dp[x - k] very fast. So the improve way is to calculate sum[i][x]. The same as dp, we only need to use two array to record sum, sum[i][x] means dp[i][x] + dp[i][x - 1] + ..... + dp[i][x - k + 1]. When x is biger than k, sum[i][x] = sum[i][x - 1] - dp[i][x - 1 - k] + dp[i][x], otherwise sum[i][x] = sum[i][x - 1] + dp[i][x]; Just remember the defination of dp and sum, and you can easily understand the code below. Previously: dp[i][j] = x, means we can use x ways to get the sum of all dice’s face-up number to j with i dice. sum[i][j] = x, means the sum of dp[i][j], dp[i][j - 1], ......, dp[i][j - k + 1]. C++ Accepted Code(7ms(98%), 6MB(97%)) class Solution { public: int dp[2][1001]; int mod; int sum[2][1001]; int numRollsToTarget(int n, int k, int target) { mod = 1e9 + 7; dp[0][0] = 1; for(int i = 0; i \u003c k; ++i) sum[0][i] = 1; for(int i = 1; i \u003c= n; ++i){ for(int x = 1; x \u003c= target; ++x){ dp[(i \u0026 1)][x] = sum[!(i \u0026 1)][x - 1]; if(x \u003e= k) sum[i \u0026 1][x] = (sum[i \u0026 1][x - 1] - dp[i \u0026 1][x - k] + mod) % mod + dp[i \u0026 1][x]; else sum[i \u0026 1][x] = sum[i \u0026 1][x - 1] + dp[i \u0026 1][x]; sum[i \u0026 1][x] %= mod; dp[i \u0026 1][x] %= mod; } memset(dp[!(i \u0026 1)], 0, sizeof(dp[!(i \u0026 1)])); memset(sum[!(i \u0026 1)], 0, sizeof(sum[!(i \u0026 1)])); } return dp[n \u0026 1][target]; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:28:3","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"10-01 91. Decode Ways Difficulty：Medium ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:29:0","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Tutorial If We could only format single digit to letter (except digit 0), the answer will be 1. So the only way to increse the answer is we combine two digits for decoding a letter. We traverse the string, define dp[i] means end with s[i - 1], we will get dp[i] ways to decode the string, for easy, we transfer dp[i] to dp[i + 1]. Like said above, if we just use one digit to decode, we won’t get new answer. So if s[i] is not ‘0’, dp[i + 1] is equal to dp[i]. If s[i] is ‘0’, dp[i + 1] is 0, because we cannot decode ‘0’ to any letter. Meanwhile, for every i (i \u003e 0), we could check whether s[i - 1, i] is an valid digit string to decode to a single letter, if so, we could let dp[i + 1] add dp[i - 1]. By this logic, evertime s[i - 1] and s[i +1] can be combined to decode a letter, the answer increase. C++ Accepted Code1:(4ms, 6.2MB) class Solution { public: int dp[105]; int numDecodings(string s) { memset(dp, 0, sizeof(dp)); dp[0] = 1; for(int i = 0; i \u003c s.size(); ++i){ if(s[i] != '0') dp[i + 1] = dp[i]; if(i \u003e 0 \u0026\u0026 (s[i - 1] == '1' || s[i - 1] == '2' \u0026\u0026 s[i] \u003c= '6')) dp[i + 1] += dp[i - 1]; printf(\"dp[%d] = %d\\n\", i, dp[i]); } return dp[s.size()]; } }; If you carefully look this code, you will find that, although we use dp to cal the answer, we only need to use dp[i], dp[i - 1], and dp[i + 1], which means we only need three avariables. So we can Smplify this code to the below one: C++ Accepted Code2:(0ms, 6MB) class Solution { public: int numDecodings(string s) { int fi = 0, se = 1; int cur = 0; for(int i = 0; i \u003c s.size(); ++i){ cur = 0; if(s[i] != '0') cur = se; if(i \u003e 0 \u0026\u0026 (s[i - 1] == '1' || s[i - 1] == '2' \u0026\u0026 s[i] \u003c= '6')) cur += fi; fi = se, se = cur; } return cur; } }; ","date":"2022-10-01","objectID":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/:29:1","tags":null,"title":"2022.10 Daily LeetCode Coding Problems Tutorial","uri":"/en/posts/2022.10-daily-leetcode-coding-problems-tutorial/"},{"categories":null,"content":"Origin Link https://leetcode.com/problems/mirror-reflection/ ","date":"2022-08-05","objectID":"/en/posts/leetcode-858-mirror-reflection-medium/:0:0","tags":null,"title":"LeetCode 858 Mirror Reflection /Medium","uri":"/en/posts/leetcode-858-mirror-reflection-medium/"},{"categories":null,"content":"Description ","date":"2022-08-05","objectID":"/en/posts/leetcode-858-mirror-reflection-medium/:0:1","tags":null,"title":"LeetCode 858 Mirror Reflection /Medium","uri":"/en/posts/leetcode-858-mirror-reflection-medium/"},{"categories":null,"content":"Tutorial Mirror reflection is a very interesting thing. Take the picture in the question as an example. If we ignore the mirror on the upper side and extend the left and right mirrors infinitely upward: when the light emitted from the origin is reflected by the mirror on the right, and then it touches the mirror on the left. The height of the point is actually 2q. After the left mirror reflect, the height of the point on the right mirror is 3q, and so on. It can be understood that every time the mirror on both sides is touched, the height difference is nq. It is also due to mirror reflection. In the above example, in fact, the position x of 2q, and the position y of the left mirror after reflection without ignoring the upper mirror, are symmetrical about the upper mirror, as shown in the figure below. Assuming that after the light from point y is reflected, the hit position is point 0. And the light reflected from point x is symmetrical with the light reflected from point y. So the next hit point with a height of 3q is also point 0. Therefore, we aren’t need to calculate the specific next reflection position after each reflection, but by calculating the above example. Get the position which height is a mutiple of p, which means meeting the requirements of the question: light reach three points 0, 1, and 2. What is special is that if you want to reach the left mirror with a height of 2p, you must have passed point 1 before. So the final calculated end point of the ray is the 2p height of the left mirror, and the answer will be point 1. From the above conditions, it is clear that the final height is LCM(p, q). Let tq = lcm/q; tp = lcm/p. It can be seen that the parity of tp determines which point is hit (because no matter which side of the mirror is, the answer is alternately distributed), and the parity of tq determines whether the left or right mirror is hit (one reflection changes one answer). This question also can be solved by brute force. The ray will be relected max 1e6 times. ","date":"2022-08-05","objectID":"/en/posts/leetcode-858-mirror-reflection-medium/:0:2","tags":null,"title":"LeetCode 858 Mirror Reflection /Medium","uri":"/en/posts/leetcode-858-mirror-reflection-medium/"},{"categories":null,"content":"Accepted Code class Solution { public: int mirrorReflection(int p, int q) { int tp = lcm(p, q) / p; int tq = lcm(p, q) / q; if(tq \u0026 1){ if(tp \u0026 1) return 1; else return 0; } else { if(tp \u0026 1) return 2; else return 1; } } int lcm(int x, int y){ return x * y / gcd(x, y); } int gcd(int x, int y){ return x % y == 0 ? y : gcd(y, x % y); } }; ","date":"2022-08-05","objectID":"/en/posts/leetcode-858-mirror-reflection-medium/:0:3","tags":null,"title":"LeetCode 858 Mirror Reflection /Medium","uri":"/en/posts/leetcode-858-mirror-reflection-medium/"},{"categories":null,"content":"Origin Link https://leetcode.com/problems/my-calendar-i/ ","date":"2022-08-03","objectID":"/en/posts/leetcode-729-my-calendar-i-medium/:0:0","tags":null,"title":"LeetCode 729 My Calendar I /Medium","uri":"/en/posts/leetcode-729-my-calendar-i-medium/"},{"categories":null,"content":"Description ","date":"2022-08-03","objectID":"/en/posts/leetcode-729-my-calendar-i-medium/:0:1","tags":null,"title":"LeetCode 729 My Calendar I /Medium","uri":"/en/posts/leetcode-729-my-calendar-i-medium/"},{"categories":null,"content":"Tutorial Throughout the constraints, we could know that O(n2) solution will be accepted. So we JUST DO IT. Using an array of pair\u003cint, int\u003e to restore every valid event’s start time and end time. For every new Events, We just iterate over the array, and judge whether any event had occupied the time or not. ","date":"2022-08-03","objectID":"/en/posts/leetcode-729-my-calendar-i-medium/:0:2","tags":null,"title":"LeetCode 729 My Calendar I /Medium","uri":"/en/posts/leetcode-729-my-calendar-i-medium/"},{"categories":null,"content":"Accepted Code class MyCalendar { public: pair\u003cint, int\u003e events[1005]; int tot; MyCalendar() { tot = 0; } bool book(int start, int end) { end--; for(int i = 0; i \u003c tot; ++i){ if(events[i].first \u003e end || events[i].second \u003c start) continue; return false; } events[tot++] = pair\u003cint, int\u003e(start, end); return true; } }; /** * Your MyCalendar object will be instantiated and called as such: * MyCalendar* obj = new MyCalendar(); * bool param_1 = obj-\u003ebook(start,end); */ ","date":"2022-08-03","objectID":"/en/posts/leetcode-729-my-calendar-i-medium/:0:3","tags":null,"title":"LeetCode 729 My Calendar I /Medium","uri":"/en/posts/leetcode-729-my-calendar-i-medium/"},{"categories":null,"content":"D. Guess The String ","date":"2022-07-09","objectID":"/en/posts/codeforces-1697-d-tutorial/:0:0","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Problem summary The Jury chosen a stringS consisting of n characters; each character of S is a lowercase Latin letter. You may ask query in two types: 1 i - query for the letterSi 2 l r - query the size of character set of Sl,Sl+1,......,Sr You are allowed to ask no more than 26 queries of the first type, and no more than 6000 queries of the second type. Output the final S you found in ! S ","date":"2022-07-09","objectID":"/en/posts/codeforces-1697-d-tutorial/:0:1","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Sample Input 5 4 u 2 g e s 1 ","date":"2022-07-09","objectID":"/en/posts/codeforces-1697-d-tutorial/:0:2","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Sample Ouput ? 2 1 5 ? 1 2 ? 2 1 2 ? 1 1 ? 1 3 ? 1 4 ? 2 4 5 ! guess ","date":"2022-07-09","objectID":"/en/posts/codeforces-1697-d-tutorial/:0:3","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Tourial First, it is easy to recognize that first type of operate is to find the letters which are first time appear. so, the first question is when we construct string, how to know whether the character has ever appeared. We define f(x, y) represent the size of the charater-set in range [x, y]. We know that 2nd op tell us the size of the charater-set. So abviously we solve the question by perform 2nd op. If we construct the string in order, we query f(1, x) and f(1, x - 1), if f(1, x) bigger than f(1, x -1), means s[x] never appeared in s[1] - s[x - 1]. and then we perform 1st op to judge the character of s[x]. After that, the new question appeares: how to know the character X, if f(1, x) equals to f(1, x - 1). Assume we know every charater in s[1] to s[x - 1], and s[x] has appeared in this range. limited by the perform times of 2nd op. we can only perform 6 times max for s[x]. Because We construct the answer string in order, the monotonicity implict in problem is: from left to right, the longer the string, the monotoncically increasing the charater-set’s size. Base on it, we could use binary search to guess s[x]. We record every character’s last position. We already know f(lastPos[mid], x - 1), so if f(mid, x) equals to f(mid, x - 1), means s[x] last appeared in rangelastPos[s[mid]]to (x - 1). Through the binary search, we could find s[x] last appeared position, and easily to konw s[x]. ","date":"2022-07-09","objectID":"/en/posts/codeforces-1697-d-tutorial/:0:4","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/codeforces-1697-d-tutorial/"},{"categories":null,"content":"Code //CPP void solveD(){ int n; scanf(\"%d\", \u0026n); char s[n + 5]; s[n + 1] = '\\0'; printf(\"? 1 1\\n\"); fflush(stdout); scanf(\" %c\", \u0026s[1]); PIC lastPos[26]; int tot = 1; lastPos[tot] = PIC(1, s[1]); for(int i = 2; i \u003c= n; ++i){ printf(\"? 2 1 %d\\n\", i); fflush(stdout); int sz; scanf(\" %d\", \u0026sz); if(sz != tot) { printf(\"? 1 %d\\n\", i); fflush(stdout); scanf(\" %c\", \u0026s[i]); lastPos[++tot] = PIC(i, s[i]); continue; } sort(lastPos + 1, lastPos + tot + 1); int l = 1, r = tot; int ans = 0; while(l \u003c= r){ int mid = l + r \u003e\u003e 1; printf(\"? 2 %d %d\\n\", lastPos[mid].first, i); fflush(stdout); scanf(\" %d\", \u0026sz); if(sz == tot - mid + 1) ans = mid, l = mid + 1; else r = mid - 1; } s[i] = lastPos[ans].second; lastPos[ans].first = i; } printf(\"! %s\\n\", s + 1); fflush(stdout); } ","date":"2022-07-09","objectID":"/en/posts/codeforces-1697-d-tutorial/:0:5","tags":null,"title":"Codeforces 1697 D Tutorial","uri":"/en/posts/codeforces-1697-d-tutorial/"}]